æœ¬æ–‡ä¸»è¦æ•´ç†Deepseekå¼€æºä»£ç çš„ä¸»è¦å†…å®¹ã€‚

## 1 - ParallelEmbedding

### è®¾è®¡åŽŸç†ä¸Žæ ¸å¿ƒæ€æƒ³

`ParallelEmbedding`çš„æ ¸å¿ƒæ€æƒ³æ˜¯**å°†åºžå¤§çš„è¯æ±‡è¡¨åˆ†å‰²æˆå¤šä¸ªéƒ¨åˆ†ï¼Œåˆ†å¸ƒåˆ°ä¸åŒçš„è®¡ç®—è®¾å¤‡ä¸Š**ã€‚æ¯ä¸ªè¿›ç¨‹åªè´Ÿè´£å­˜å‚¨å’Œå¤„ç†ä¸€éƒ¨åˆ†è¯æ±‡çš„åµŒå…¥å‘é‡ï¼Œä»Žè€Œæ˜¾è‘—é™ä½Žå•ä¸ªè®¾å¤‡çš„å†…å­˜åŽ‹åŠ›ã€‚

è¿™ç§è®¾è®¡å¯¹äºŽçŽ°ä»£å¤§è¯­è¨€æ¨¡åž‹è‡³å…³é‡è¦ï¼Œä»¥DeepSeek-V3ä¸ºä¾‹ï¼Œè¯æ±‡é‡è¾¾åˆ°129,280ï¼ŒåµŒå…¥ç»´åº¦ä¸º7168ï¼Œå¦‚æžœä½¿ç”¨float32å­˜å‚¨ï¼Œå•ä¸ªåµŒå…¥å±‚å°±éœ€è¦çº¦3.44GBæ˜¾å­˜ã€‚é€šè¿‡å¹¶è¡ŒåŒ–ï¼Œå¯ä»¥å°†è¿™ä¸ªå†…å­˜éœ€æ±‚å¹³å‡åˆ†é…åˆ°å¤šä¸ªGPUä¸Šã€‚

### åˆå§‹åŒ–è¿‡ç¨‹åˆ†æž

```python
def __init__(self, vocab_size: int, dim: int):
    super().__init__()
    self.vocab_size = vocab_size
    self.dim = dim
    assert vocab_size % world_size == 0  # ç¡®ä¿å‡åŒ€åˆ†é…
    self.part_vocab_size = (vocab_size // world_size)
    self.vocab_start_idx = rank * self.part_vocab_size
    self.vocab_end_idx = self.vocab_start_idx + self.part_vocab_size
    self.weight = nn.Parameter(torch.empty(self.part_vocab_size, self.dim))
```

åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„å…³é”®æ­¥éª¤åŒ…æ‹¬ï¼š
- **å‡åŒ€åˆ†ç‰‡æ£€æŸ¥**ï¼šç¡®ä¿è¯æ±‡è¡¨å¤§å°èƒ½è¢«è¿›ç¨‹æ•°æ•´é™¤ï¼Œè¿™æ˜¯å®žçŽ°è´Ÿè½½å‡è¡¡çš„å‰æ
- **ç´¢å¼•è®¡ç®—**ï¼šæ¯ä¸ªè¿›ç¨‹æ ¹æ®å…¶`rank`è®¡ç®—è‡ªå·±è´Ÿè´£çš„è¯æ±‡èŒƒå›´ï¼ˆä»Ž`vocab_start_idx`åˆ°`vocab_end_idx`ï¼‰
- **æƒé‡åˆå§‹åŒ–**ï¼šæ¯ä¸ªè¿›ç¨‹åªåˆå§‹åŒ–è‡ªå·±è´Ÿè´£çš„é‚£éƒ¨åˆ†åµŒå…¥æƒé‡ï¼Œå¤§å¤§å‡å°‘å•å¡å†…å­˜å ç”¨

### å‰å‘ä¼ æ’­æœºåˆ¶è¯¦è§£

å‰å‘ä¼ æ’­è¿‡ç¨‹ä½“çŽ°äº†åˆ†å¸ƒå¼è®¡ç®—çš„æ ¸å¿ƒé€»è¾‘ï¼š

#### 1. æŽ©ç ç”Ÿæˆä¸Žç´¢å¼•è½¬æ¢
```python
if world_size > 1:
    mask = (x < self.vocab_start_idx) | (x >= self.vocab_end_idx)
    x = x - self.vocab_start_idx
    x[mask] = 0
```

**æŽ©ç æœºåˆ¶**ç”¨äºŽæ ‡è¯†å“ªäº›tokenç´¢å¼•ä¸å±žäºŽå½“å‰è¿›ç¨‹è´Ÿè´£çš„èŒƒå›´ã€‚å¯¹äºŽè¶…å‡ºèŒƒå›´çš„ç´¢å¼•ï¼Œé€šè¿‡å‡åŽ»èµ·å§‹ç´¢å¼•å¹¶ç½®é›¶ï¼Œå°†å…¶æ˜ å°„åˆ°å®‰å…¨ä½ç½®ï¼Œé¿å…è¶Šç•Œè®¿é—®ã€‚

#### 2. æœ¬åœ°åµŒå…¥æŸ¥æ‰¾
```python
y = F.embedding(x, self.weight)
```
æ¯ä¸ªè¿›ç¨‹ä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„éƒ¨åˆ†æƒé‡è¿›è¡Œæ ‡å‡†çš„åµŒå…¥æŸ¥æ‰¾æ“ä½œã€‚æ­¤æ—¶ï¼Œä¸å±žäºŽå½“å‰è¿›ç¨‹èŒƒå›´çš„tokenä¼šè¢«æŸ¥æ‰¾ä¸ºèµ·å§‹ä½ç½®çš„åµŒå…¥å‘é‡ï¼ˆå› ä¸ºç´¢å¼•è¢«ç½®é›¶ï¼‰ã€‚

#### 3. ç»“æžœæ¸…é›¶ä¸Žå…¨å±€èšåˆ
```python
if world_size > 1:
    y[mask] = 0  # æ¸…é›¶ä¸å±žäºŽæœ¬è¿›ç¨‹çš„ç»“æžœ
    dist.all_reduce(y)  # å…¨å±€æ±‚å’Œèšåˆ
```

è¿™æ˜¯æœ€å…³é”®çš„æ­¥éª¤ï¼šé€šè¿‡æŽ©ç å°†ä¸å±žäºŽæœ¬è¿›ç¨‹è´Ÿè´£çš„tokenåµŒå…¥ç»“æžœæ¸…é›¶ï¼Œç„¶åŽä½¿ç”¨`dist.all_reduce`è¿›è¡Œè·¨è¿›ç¨‹é€šä¿¡ï¼Œå°†æ‰€æœ‰è¿›ç¨‹çš„å±€éƒ¨ç»“æžœæ±‚å’Œå¾—åˆ°å®Œæ•´çš„åµŒå…¥è¡¨ç¤ºã€‚

### å·¥ä½œæµç¨‹ç¤ºä¾‹

å‡è®¾åœ¨2å¡çŽ¯å¢ƒä¸‹ï¼ˆTP_SIZE=2ï¼‰ï¼Œè¯æ±‡è¡¨å¤§å°ä¸º12ï¼Œè¾“å…¥ä¸º`["cat", "dog"]`å¯¹åº”çš„token IDä¸º`[2, 10]`ï¼š

- **Rank 0**è´Ÿè´£è¯æ±‡ID `[0, 1, 2, 3, 4, 5]`ï¼Œè®¡ç®—"cat"(ID=2)çš„åµŒå…¥ï¼Œå°†"dog"(ID=10)çš„ç»“æžœæ¸…é›¶
- **Rank 1**è´Ÿè´£è¯æ±‡ID `[6, 7, 8, 9, 10, 11]`ï¼Œè®¡ç®—"dog"(ID=10)çš„åµŒå…¥ï¼Œå°†"cat"(ID=2)çš„ç»“æžœæ¸…é›¶
- é€šè¿‡`all_reduce`æ±‚å’ŒåŽï¼Œä¸¤ä¸ªè¿›ç¨‹éƒ½å¾—åˆ°å®Œæ•´çš„æ­£ç¡®åµŒå…¥ç»“æžœ

## 2 - linear

### 2.1 - linearæŽ¥å£

```python
def linear(x, weight, bias=None, scale_fmt=None):
    if weight.element_size() > 1:  # æƒ…å†µ1ï¼šæƒé‡å·²æ˜¯é«˜ç²¾åº¦ï¼ˆå¦‚BF16/FP16ï¼‰
        return F.linear(x, weight, bias)  # ç›´æŽ¥è®¡ç®—ï¼Œæ— éœ€åé‡åŒ–
    elif gemm_impl == "bf16":  # æƒ…å†µ2ï¼šæŒ‡å®šä½¿ç”¨BF16è®¡ç®—è·¯å¾„
        weight = weight_dequant(weight, weight.scale)  # å°†FP8/INT8æƒé‡åé‡åŒ–åˆ°BF16
        return F.linear(x, weight, bias)
    else:  # æƒ…å†µ3ï¼šFP8ç›´æŽ¥è®¡ç®—è·¯å¾„
        x, scale = act_quant(x, block_size, scale_fmt)  # å°†æ¿€æ´»å€¼ä¹Ÿé‡åŒ–ä¸ºFP8
        y = fp8_gemm(x, scale, weight, weight.scale)  # è°ƒç”¨FP8 GEMMå†…æ ¸ç›´æŽ¥è®¡ç®—
        if bias is not None:
            y += bias
        return y
```

è¿™ä¸ªé€»è¾‘æ¸…æ™°åœ°è¯´æ˜Žäº†ä¸‰ç§æƒ…å†µï¼š
*   **é«˜ç²¾åº¦æƒé‡**ï¼šå·²ç»æ˜¯BF16/FP16ï¼Œç›´æŽ¥è®¡ç®—ã€‚
*   **BF16è·¯å¾„**ï¼šå½“æŒ‡å®šæˆ–ç¡¬ä»¶ä¸æ”¯æŒFP8ç›´æŽ¥è®¡ç®—æ—¶ï¼Œå°†ä½Žç²¾åº¦æƒé‡åé‡åŒ–åˆ°BF16è¿›è¡Œè®¡ç®—ã€‚
*   **FP8è·¯å¾„**ï¼šå½“æ¡ä»¶å…è®¸æ—¶ï¼Œä½¿ç”¨ä¸“é—¨çš„FP8è®¡ç®—å†…æ ¸ï¼Œé¿å…åé‡åŒ–ã€‚

### 2.2 - class Linear

### **`scale_fmt`ï¼šç»Ÿä¸€çš„æ ¼å¼è§„åˆ™**
`scale_fmt` æ˜¯ä¸€ä¸ª**å…¨å±€æ€§é…ç½®**ï¼Œå®ƒè§„å®šäº†æ¨¡åž‹ä¸­æ‰€æœ‰æƒé‡é‡åŒ–ç¼©æ”¾å› å­åœ¨å­˜å‚¨æ—¶çš„æ•°æ®æ ¼å¼ã€‚ä»¥ DeepSeek-V3.1 é‡‡ç”¨çš„ `"ue8m0"` ä¸ºä¾‹ï¼š
*   **`u`**ï¼šä»£è¡¨æ— ç¬¦å·ï¼ˆUnsignedï¼‰ï¼Œè¡¨ç¤ºç¼©æ”¾å› å­æ€»æ˜¯æ­£æ•°ã€‚
*   **`e8`**ï¼šä»£è¡¨8ä½æŒ‡æ•°ï¼ˆExponentï¼‰ï¼Œè¿™æ„å‘³ç€ç¼©æ”¾å› å­å¯ä»¥è¡¨ç¤ºä¸€ä¸ªéžå¸¸å¤§çš„åŠ¨æ€èŒƒå›´ï¼ˆé‡çº§ï¼‰ã€‚
*   **`m0`**ï¼šä»£è¡¨0ä½å°¾æ•°ï¼ˆMantissaï¼‰ï¼Œæ„å‘³ç€ç¼©æ”¾å› å­æœ¬èº«æ²¡æœ‰å°æ•°éƒ¨åˆ†ï¼Œæ˜¯ä¸€ä¸ªæ•´æ•°ã€‚

è¿™ç§æ ¼å¼çš„ä¼˜åŠ¿åœ¨äºŽï¼Œå®ƒç”¨8ä½æ•´æ•°çš„å­˜å‚¨æˆæœ¬ï¼Œå®žçŽ°äº†ä¸ŽFP32æŒ‡æ•°ä½ç›¸è¿‘çš„å¹¿é˜”è¡¨ç¤ºèŒƒå›´ï¼Œéžå¸¸é€‚åˆå­˜å‚¨åªéœ€è¦è¡¨ç¤ºé‡çº§ã€å¯¹ç»å¯¹ç²¾åº¦è¦æ±‚ä¸é«˜çš„ç¼©æ”¾å› å­ã€‚

### **`self.weight.scale`ï¼šå…·ä½“çš„æ•°å€¼å­˜å‚¨**
åœ¨æ¨¡åž‹åˆå§‹åŒ–æ—¶ï¼Œå¦‚æžœæ£€æµ‹åˆ°æƒé‡éœ€è¦é‡åŒ–ï¼ˆä¾‹å¦‚ï¼Œ`self.weight.element_size() == 1`ï¼‰ï¼Œå°±ä¼šæ ¹æ®æƒé‡å¤§å°å’Œåˆ†å—ç­–ç•¥ï¼ˆ`block_size`ï¼‰åˆ›å»º `self.weight.scale` å‚æ•°ã€‚å®ƒæ˜¯ä¸€ä¸ªå¼ é‡ï¼Œå…¶æ¯ä¸ªå…ƒç´ éƒ½å­˜å‚¨äº†å¯¹åº”æƒé‡åˆ†å—çš„å…·ä½“ç¼©æ”¾æ•°å€¼ã€‚è¿™äº›æ•°å€¼åœ¨é‡åŒ–æ ¡å‡†æˆ–è®­ç»ƒè¿‡ç¨‹ä¸­è¢«è®¡ç®—å‡ºæ¥ã€‚

**å…³é”®ç‚¹**ï¼š`self.weight.scale` å¼ é‡ä¸­çš„æ¯ä¸€ä¸ªå…·ä½“æ•°å€¼ï¼Œéƒ½ä¼šæŒ‰ç…§ `scale_fmt` æ‰€è§„å®šçš„æ ¼å¼ï¼ˆå¦‚`"ue8m0"`ï¼‰è¿›è¡Œå­˜å‚¨å’Œå‚ä¸ŽåŽç»­è®¡ç®—ã€‚
æ˜¯å·¥ä¸šçº§æ¨¡åž‹é‡åŒ–ä¸­çš„ä¸€é¡¹ç²¾å¦™è®¾è®¡ã€‚å¸Œæœ›è¿™ä¸ªè§£é‡Šèƒ½å¸®åŠ©ä½ ç†è§£å®ƒä»¬ä¹‹é—´çš„åä½œå…³ç³»ï¼å¦‚æžœå¯¹é‡åŒ–ä¸­çš„å…¶ä»–æ¦‚å¿µï¼Œå¦‚åˆ†å—é‡åŒ–ï¼ˆ`block_size`ï¼‰æˆ–æ¿€æ´»å€¼é‡åŒ–è¿˜æœ‰ç–‘é—®ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­æŽ¢è®¨ã€‚

## 2.3 - ColumnParallelLinear

### âš™ï¸ æ ¸å¿ƒè®¾è®¡æ€è·¯

`ColumnParallelLinear` çš„è®¾è®¡éµå¾ª **â€œæ‹†åˆ†-è®¡ç®—-èšåˆâ€** çš„å¹¶è¡Œæ¨¡å¼ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯å°†çº¿æ€§å±‚åºžå¤§çš„æƒé‡çŸ©é˜µæ²¿**è¾“å‡ºç»´åº¦**è¿›è¡Œåˆ‡åˆ†ï¼Œä½¿æ¯ä¸ªGPUåªéœ€è´Ÿè´£è®¡ç®—æ€»è¾“å‡ºçš„ä¸€éƒ¨åˆ†ã€‚

å®ƒä¸Ž `RowParallelLinear` ååŒå·¥ä½œï¼Œæž„æˆäº†Transformer MLPå±‚ä¸­çš„æ ‡å‡†å¹¶è¡Œæ¨¡å¼ï¼š`ColumnParallelLinear` ç”¨äºŽMLPç¬¬ä¸€å±‚ï¼Œ`RowParallelLinear` ç”¨äºŽç¬¬äºŒå±‚ ã€‚

### ðŸ” ä»£ç é€å±‚è§£æž

#### 1. åˆå§‹åŒ–è¿‡ç¨‹
```python
def __init__(self, in_features: int, out_features: int, bias: bool = False, dtype = None):
    assert out_features % world_size == 0  # ç¡®ä¿å‡åŒ€åˆ†å‰²
    self.part_out_features = out_features // world_size  # æ¯ä¸ªGPUè´Ÿè´£çš„è¾“å‡ºç‰¹å¾æ•°
    super().__init__(in_features, self.part_out_features, bias, dtype)  # è°ƒç”¨çˆ¶ç±»åˆå§‹åŒ–
```

åˆå§‹åŒ–é˜¶æ®µçš„å…³é”®æ­¥éª¤åŒ…æ‹¬ï¼š
- **å‡åŒ€æ€§æ£€æŸ¥**ï¼šç¡®ä¿è¾“å‡ºç‰¹å¾æ•°èƒ½è¢«GPUæ•°é‡æ•´é™¤ï¼Œè¿™æ˜¯å®žçŽ°è´Ÿè½½å‡è¡¡çš„å‰æ
- **å±€éƒ¨ç»´åº¦è®¡ç®—**ï¼šè®¡ç®—æ¯ä¸ªGPUéœ€è¦è´Ÿè´£çš„è¾“å‡ºç‰¹å¾æ•° (`part_out_features`)
- **çˆ¶ç±»åˆå§‹åŒ–**ï¼šè°ƒç”¨çˆ¶ç±» `Linear` çš„åˆå§‹åŒ–ï¼Œä½†ä¼ å…¥çš„æ˜¯å±€éƒ¨è¾“å‡ºç»´åº¦

ä¾‹å¦‚ï¼Œåœ¨2å¡çŽ¯å¢ƒä¸‹ï¼Œè‹¥åŽŸå§‹çº¿æ€§å±‚è¾“å‡ºç»´åº¦ä¸º1024ï¼Œåˆ™æ¯ä¸ªGPUä¸Šçš„ `ColumnParallelLinear` åªè¾“å‡º512ç»´ã€‚

#### 2. å‰å‘ä¼ æ’­
```python
def forward(self, x: torch.Tensor) -> torch.Tensor:
    y = linear(x, self.weight, self.bias)  # æœ¬åœ°è®¡ç®—éƒ¨åˆ†è¾“å‡º
    return y
```

å‰å‘ä¼ æ’­ç›¸å¯¹ç®€æ´ï¼Œä½†èƒŒåŽæœ‰é‡è¦è®¾è®¡è€ƒé‡ï¼š
- **æœ¬åœ°è®¡ç®—**ï¼šæ¯ä¸ªGPUä½¿ç”¨å®Œæ•´çš„è¾“å…¥ `x` å’Œæœ¬åœ°éƒ¨åˆ†æƒé‡è¿›è¡Œè®¡ç®—
- **å»¶è¿Ÿèšåˆ**ï¼šä¸Žå…¸åž‹å®žçŽ°ä¸åŒï¼Œæ­¤å¤„æ²¡æœ‰æ˜¾å¼çš„ `all_gather` æ“ä½œï¼Œèšåˆå¯èƒ½å»¶è¿Ÿåˆ°åŽç»­å±‚

### ðŸ“Š ä¸Žä¼ ç»Ÿå®žçŽ°çš„å¯¹æ¯”

| ç‰¹æ€§ | å…¸åž‹ `ColumnParallelLinear` | æ­¤ç®€åŒ–å®žçŽ° |
|------|----------------------------|------------|
| **é€šä¿¡æ—¶æœº** | å‰å‘ä¼ æ’­ä¸­ç«‹å³ `all_gather` | å¯èƒ½å»¶è¿Ÿèšåˆ |
| **å†…å­˜å ç”¨** | èšåˆåŽæ˜¾å­˜å ç”¨è¾ƒå¤§ | ä¿æŒå±€éƒ¨è¾“å‡ºï¼ŒèŠ‚çœæ˜¾å­˜ |
| **è®¾è®¡å“²å­¦** | æ˜¾å¼é€šä¿¡ï¼Œé€»è¾‘æ¸…æ™° | éšå¼é€šä¿¡ï¼Œä¼˜åŒ–æ•´ä½“æµç¨‹ |

### ðŸ”„ å®Œæ•´å·¥ä½œæµç¨‹ç¤ºä¾‹

ä»¥2å¡çŽ¯å¢ƒä¸ºä¾‹ï¼Œå‡è®¾è¾“å…¥ç»´åº¦ä¸º512ï¼Œè¾“å‡ºç»´åº¦ä¸º1024ï¼š

1. **GPU 0**ï¼šè®¡ç®— `x @ W0^T`ï¼Œå¾—åˆ°512ç»´å±€éƒ¨è¾“å‡º
2. **GPU 1**ï¼šè®¡ç®— `x @ W1^T`ï¼Œå¾—åˆ°å¦å¤–512ç»´å±€éƒ¨è¾“å‡º  
3. **é€šä¿¡èšåˆ**ï¼šé€šè¿‡ `all_gather` å°†ä¸¤éƒ¨åˆ†è¾“å‡ºæ‹¼æŽ¥æˆå®Œæ•´çš„1024ç»´ç»“æžœ

## 2.4 - RowParallelLinear

è¿™ä¸ª `RowParallelLinear` ç±»æ˜¯å¼ é‡å¹¶è¡Œä¸­ä¸Ž `ColumnParallelLinear` é…å¯¹ä½¿ç”¨çš„å…³é”®ç»„ä»¶ï¼Œå®ƒé‡‡ç”¨**è¡Œå¹¶è¡Œ**æ–¹å¼å°†çº¿æ€§å±‚çš„è®¡ç®—åˆ†å¸ƒåˆ°å¤šä¸ªGPUä¸Šã€‚ä¸‹é¢æˆ‘å°†ç»“åˆå…¶è®¾è®¡åŽŸç†å’Œå®žçŽ°ç»†èŠ‚è¿›è¡Œåˆ†æžã€‚

### âš™ï¸ æ ¸å¿ƒè®¾è®¡æ€è·¯

`RowParallelLinear` çš„æ ¸å¿ƒæ€æƒ³æ˜¯**æ²¿è¾“å…¥ç»´åº¦æ‹†åˆ†è®¡ç®—è´£ä»»**ã€‚ä¸Ž `ColumnParallelLinear` å°†è¾“å‡ºç‰¹å¾æ‹†åˆ†ä¸åŒï¼Œ`RowParallelLinear` å°†è¾“å…¥ç‰¹å¾æ‹†åˆ†ï¼Œæ¯ä¸ªGPUåªå¤„ç†è¾“å…¥å¼ é‡çš„ä¸€éƒ¨åˆ†ï¼Œæœ€åŽé€šè¿‡é€šä¿¡æ“ä½œèšåˆç»“æžœã€‚

è¿™ç§è®¾è®¡é€šå¸¸ä¸Ž `ColumnParallelLinear` ç»“åˆä½¿ç”¨ï¼Œæž„æˆTransformer MLPå±‚çš„æ ‡å‡†å¹¶è¡Œæ¨¡å¼ï¼š`ColumnParallelLinear` ç”¨äºŽMLPç¬¬ä¸€å±‚ï¼ˆæŒ‰åˆ—æ‹†åˆ†ï¼‰ï¼Œ`RowParallelLinear` ç”¨äºŽç¬¬äºŒå±‚ï¼ˆæŒ‰è¡Œæ‹†åˆ†ï¼‰ã€‚

### ðŸ” ä»£ç å®žçŽ°è§£æž

#### 1. åˆå§‹åŒ–è¿‡ç¨‹
```python
def __init__(self, in_features: int, out_features: int, bias: bool = False, dtype = None):
    assert in_features % world_size == 0  # ç¡®ä¿è¾“å…¥ç‰¹å¾å‡åŒ€åˆ†å‰²
    self.part_in_features = in_features // world_size  # æ¯ä¸ªGPUè´Ÿè´£çš„è¾“å…¥ç‰¹å¾æ•°
    super().__init__(self.part_in_features, out_features, bias, dtype)
```
åˆå§‹åŒ–é˜¶æ®µçš„å…³é”®æ­¥éª¤åŒ…æ‹¬ï¼š
- **å‡åŒ€æ€§æ£€æŸ¥**ï¼šç¡®ä¿è¾“å…¥ç‰¹å¾æ•°èƒ½è¢«GPUæ•°é‡æ•´é™¤ï¼Œå®žçŽ°è´Ÿè½½å‡è¡¡
- **å±€éƒ¨ç»´åº¦è®¡ç®—**ï¼šè®¡ç®—æ¯ä¸ªGPUéœ€è¦å¤„ç†çš„è¾“å…¥ç‰¹å¾æ•° (`part_in_features`)
- **çˆ¶ç±»åˆå§‹åŒ–**ï¼šè°ƒç”¨çˆ¶ç±» `Linear`ï¼Œä½†ä¼ å…¥çš„æ˜¯å±€éƒ¨è¾“å…¥ç»´åº¦

ä¾‹å¦‚ï¼Œåœ¨2å¡çŽ¯å¢ƒä¸‹ï¼Œè‹¥åŽŸå§‹çº¿æ€§å±‚è¾“å…¥ç»´åº¦ä¸º1024ï¼Œåˆ™æ¯ä¸ªGPUä¸Šçš„ `RowParallelLinear` åªå¤„ç†512ç»´è¾“å…¥ã€‚

#### 2. å‰å‘ä¼ æ’­æœºåˆ¶
```python
def forward(self, x: torch.Tensor) -> torch.Tensor:
    y = linear(x, self.weight)  # æœ¬åœ°è®¡ç®—
    if world_size > 1:
        dist.all_reduce(y)  # å…¨å±€æ±‚å’Œèšåˆ
    if self.bias is not None:
        y += self.bias  # æ·»åŠ åç½®
    return y
```
å‰å‘ä¼ æ’­åŒ…å«ä¸‰ä¸ªå…³é”®æ­¥éª¤ï¼š
1. **æœ¬åœ°è®¡ç®—**ï¼šæ¯ä¸ªGPUä½¿ç”¨æœ¬åœ°éƒ¨åˆ†è¾“å…¥å’Œå®Œæ•´æƒé‡è¿›è¡Œè®¡ç®—
2. **ç»“æžœèšåˆ**ï¼šé€šè¿‡ `all_reduce` å¯¹æ‰€æœ‰GPUçš„è¾“å‡ºè¿›è¡Œæ±‚å’Œï¼Œå¾—åˆ°å®Œæ•´ç»“æžœ
3. **åç½®å¤„ç†**ï¼šåç½®é¡¹åœ¨èšåˆåŽåŠ å…¥ï¼Œç¡®ä¿æ•°å€¼ä¸€è‡´æ€§

### ðŸ“Š ä¸ŽColumnParallelLinearçš„å¯¹æ¯”

ä¸ºäº†æ›´æ¸…æ™°ç†è§£ä¸¤è€…çš„åŒºåˆ«ï¼Œä¸‹è¡¨å¯¹æ¯”äº†å®ƒä»¬çš„å…³é”®ç‰¹æ€§ï¼š

| ç‰¹æ€§ | ColumnParallelLinear | RowParallelLinear |
|------|---------------------|------------------|
| **æ‹†åˆ†ç»´åº¦** | è¾“å‡ºç‰¹å¾ï¼ˆåˆ—æ–¹å‘ï¼‰ | è¾“å…¥ç‰¹å¾ï¼ˆè¡Œæ–¹å‘ï¼‰ |
| **é€šä¿¡æ“ä½œ** | All-Gatherï¼ˆæ‹¼æŽ¥ï¼‰ | All-Reduceï¼ˆæ±‚å’Œï¼‰ |
| **åœ¨MLPä¸­çš„ä½ç½®** | ç¬¬ä¸€å±‚ | ç¬¬äºŒå±‚ |
| **è®¡ç®—æ¨¡å¼** | è¾“å…¥å®Œæ•´ï¼Œæƒé‡éƒ¨åˆ† | è¾“å…¥éƒ¨åˆ†ï¼Œæƒé‡å®Œæ•´ |
| **é€‚ç”¨åœºæ™¯** | è¾“å‡ºç»´åº¦å¤§çš„å±‚ | è¾“å…¥ç»´åº¦å¤§çš„å±‚ |

### ðŸ”„ å®Œæ•´å·¥ä½œæµç¨‹ç¤ºä¾‹

ä»¥2å¡çŽ¯å¢ƒä¸‹çš„MLPå±‚ä¸ºä¾‹ï¼Œå‡è®¾è¾“å…¥ç»´åº¦ä¸º512ï¼Œä¸­é—´ç»´åº¦ä¸º1024ï¼Œè¾“å‡ºç»´åº¦ä¸º512ï¼š

1. **ç¬¬ä¸€å±‚ï¼ˆColumnParallelLinearï¼‰**ï¼š
   - GPU 0ï¼šè®¡ç®— `x @ W1_0^T`ï¼Œå¾—åˆ°512ç»´å±€éƒ¨è¾“å‡º
   - GPU 1ï¼šè®¡ç®— `x @ W1_1^T`ï¼Œå¾—åˆ°å¦å¤–512ç»´å±€éƒ¨è¾“å‡º
   - é€šè¿‡All-Gatheræ‹¼æŽ¥æˆ1024ç»´å®Œæ•´ä¸­é—´ç»“æžœ

2. **ç¬¬äºŒå±‚ï¼ˆRowParallelLinearï¼‰**ï¼š
   - GPU 0ï¼šä½¿ç”¨å‰512ç»´è¾“å…¥è®¡ç®— `x_part_0 @ W2`
   - GPU 1ï¼šä½¿ç”¨åŽ512ç»´è¾“å…¥è®¡ç®— `x_part_1 @ W2`  
   - é€šè¿‡All-Reduceæ±‚å’Œå¾—åˆ°æœ€ç»ˆçš„512ç»´è¾“å‡º

## 3.0 - precompute_freqs_cis

### åŠŸèƒ½ä¸Žæ”¹è¿›æ¦‚è§ˆ

è¿™ä¸ª`precompute_freqs_cis`å‡½æ•°åœ¨æ ‡å‡†RoPEåŸºç¡€ä¸Šå¢žåŠ äº†**åŠ¨æ€é¢‘çŽ‡è°ƒæ•´æœºåˆ¶**ï¼Œä¸»è¦è§£å†³æ¨¡åž‹åœ¨æŽ¨ç†æ—¶å¤„ç†**é•¿äºŽè®­ç»ƒåºåˆ—**çš„æ–‡æœ¬æ—¶çš„æ€§èƒ½ä¸‹é™é—®é¢˜ã€‚

#### æ ¸å¿ƒå‚æ•°è¯´æ˜Ž
| å‚æ•° | ä½œç”¨ | ä¸Žä¼ ç»ŸRoPEå¯¹æ¯” |
|------|------|---------------|
| `beta_fast` / `beta_slow` | æŽ§åˆ¶é¢‘çŽ‡è°ƒæ•´çš„æ—‹è½¬é€Ÿåº¦è¾¹ç•Œ | æ–°å¢žï¼Œç”¨äºŽåŠ¨æ€å¤–æŽ¨ |
| `rope_theta` | åŸºç¡€é¢‘çŽ‡å‚æ•°ï¼ˆé€šå¸¸10000ï¼‰ | ä¿ç•™ä¼ ç»Ÿå‚æ•° |
| `rope_factor` | å¤–æŽ¨æ—¶çš„ç¼©æ”¾å› å­ | æ–°å¢žï¼ŒæŽ§åˆ¶é¢‘çŽ‡ç¼©æ”¾ |
| `original_seq_len` | è®­ç»ƒæ—¶çš„åºåˆ—é•¿åº¦ | æ–°å¢žï¼Œä½œä¸ºè°ƒæ•´åŸºå‡† |

### æ ¸å¿ƒç®—æ³•è§£æž

#### 1. é¢‘çŽ‡æ ¡æ­£ç»´åº¦è®¡ç®—
```python
def find_correction_dim(num_rotations, dim, base, max_seq_len):
    return dim * math.log(max_seq_len / (num_rotations * 2 * math.pi)) / (2 * math.log(base))
```
è¿™ä¸ªå‡½æ•°è®¡ç®—åœ¨ç»™å®šæ—‹è½¬æ¬¡æ•°ä¸‹éœ€è¦è°ƒæ•´çš„ç»´åº¦ä½ç½®ï¼ŒåŸºäºŽå¯¹æ•°ç¼©æ”¾æ¥ç¡®ä¿ä¸åŒç»´åº¦çš„é¢‘çŽ‡è°ƒæ•´åˆç†æ€§ã€‚

#### 2. æ ¡æ­£èŒƒå›´ç¡®å®š
```python
def find_correction_range(low_rot, high_rot, dim, base, max_seq_len):
    low = math.floor(find_correction_dim(low_rot, dim, base, max_seq_len))
    high = math.ceil(find_correction_dim(high_rot, dim, base, max_seq_len))
    return max(low, 0), min(high, dim-1)
```
ç¡®å®šéœ€è¦åº”ç”¨åŠ¨æ€è°ƒæ•´çš„ç»´åº¦èŒƒå›´ï¼Œ`beta_fast`å’Œ`beta_slow`åˆ†åˆ«å®šä¹‰äº†æ—‹è½¬é€Ÿåº¦çš„ä¸Šä¸‹ç•Œã€‚

#### 3. çº¿æ€§æ–œå¡å‡½æ•°
```python
def linear_ramp_factor(min, max, dim):
    linear_func = (torch.arange(dim, dtype=torch.float32) - min) / (max - min)
    ramp_func = torch.clamp(linear_func, 0, 1)
    return ramp_func
```
åˆ›å»ºå¹³æ»‘çš„è¿‡æ¸¡å‡½æ•°ï¼Œé¿å…åœ¨ç»´åº¦è¾¹ç•Œå¤„å‡ºçŽ°çªå˜ï¼Œä¿è¯é¢‘çŽ‡è°ƒæ•´çš„è¿žç»­æ€§ã€‚

### åŠ¨æ€å¤–æŽ¨æœºåˆ¶

#### æ ‡å‡†æƒ…å†µä¸‹çš„é¢‘çŽ‡è®¡ç®—
```python
freqs = 1.0 / (base ** (torch.arange(0, dim, 2, dtype=torch.float32) / dim))
```
è¿™æ˜¯ä¼ ç»Ÿçš„RoPEé¢‘çŽ‡è®¡ç®—ï¼Œä¸ŽåŽŸå§‹å®žçŽ°ä¸€è‡´ã€‚

#### é•¿åºåˆ—åŠ¨æ€è°ƒæ•´
```python
if seqlen > args.original_seq_len:
    low, high = find_correction_range(beta_fast, beta_slow, dim, base, args.original_seq_len)
    smooth = 1 - linear_ramp_factor(low, high, dim // 2)
    freqs = freqs / factor * (1 - smooth) + freqs * smooth
```

**è¿™æ˜¯æ ¸å¿ƒæ”¹è¿›ç‚¹**ï¼Œé€šè¿‡çº¿æ€§æ’å€¼åœ¨ä¸¤ç§é¢‘çŽ‡è®¡ç®—é—´å¹³æ»‘è¿‡æ¸¡ï¼š
- **ä½Žé¢‘ç»´åº¦**ï¼ˆé è¿‘ç´¢å¼•0ï¼‰ï¼šä½¿ç”¨`freqs / factor`ï¼Œé™ä½Žé¢‘çŽ‡ä»¥é€‚åº”é•¿åºåˆ—
- **é«˜é¢‘ç»´åº¦**ï¼ˆé è¿‘ç´¢å¼•æœ«å°¾ï¼‰ï¼šä¿æŒåŽŸå§‹`freqs`ï¼Œç»´æŠ¤å±€éƒ¨ä½ç½®å…³ç³»
- **ä¸­é—´ç»´åº¦**ï¼šé€šè¿‡`smooth`å› å­å¹³æ»‘è¿‡æ¸¡

### å·¥ä½œæµç¨‹æ€»ç»“

1. **åŸºç¡€é¢‘çŽ‡è®¡ç®—**ï¼šä¸Žä¼ ç»ŸRoPEç›¸åŒï¼Œç”Ÿæˆå‡ ä½•åºåˆ—çš„é¢‘çŽ‡å‘é‡
2. **é•¿åº¦æ£€æµ‹**ï¼šåˆ¤æ–­å½“å‰åºåˆ—æ˜¯å¦è¶…è¿‡è®­ç»ƒé•¿åº¦
3. **åŠ¨æ€è°ƒæ•´**ï¼ˆå¦‚éœ€è¦ï¼‰ï¼šè®¡ç®—æ ¡æ­£èŒƒå›´ï¼Œåº”ç”¨å¹³æ»‘çš„é¢‘çŽ‡è°ƒæ•´
4. **ä½ç½®å¤–ç§¯**ï¼šå°†é¢‘çŽ‡ä¸Žä½ç½®ç´¢å¼•ç»“åˆï¼Œç”Ÿæˆæ—‹è½¬è§’åº¦çŸ©é˜µ
5. **å¤æ•°è½¬æ¢**ï¼šè½¬æ¢ä¸ºæžåæ ‡å½¢å¼çš„å¤æ•°è¡¨ç¤ºï¼Œç”¨äºŽåŽç»­æ—‹è½¬æ“ä½œ

### æŠ€æœ¯ä¼˜åŠ¿åˆ†æž

#### ä¸Žä¼ ç»ŸRoPEå¯¹æ¯”
| ç‰¹æ€§ | ä¼ ç»ŸRoPE | æ­¤åŠ¨æ€å®žçŽ° |
|------|----------|------------|
| å¤–æŽ¨èƒ½åŠ› | æœ‰é™ï¼Œæ€§èƒ½éšé•¿åº¦å¢žåŠ ä¸‹é™ | æ˜¾è‘—æå‡ï¼Œæ”¯æŒæ›´é•¿åºåˆ— |
| é¢‘çŽ‡ç­–ç•¥ | å›ºå®šå‡ ä½•åºåˆ— | åŠ¨æ€è°ƒæ•´ï¼Œé€‚åº”åºåˆ—é•¿åº¦ |
| è¶…å‚æ•° | ä»…`theta` | å¤šå‚æ•°ç²¾ç»†æŽ§åˆ¶å¤–æŽ¨è¡Œä¸º |

#### å®žé™…åº”ç”¨ä»·å€¼
è¿™ç§æ”¹è¿›è®©æ¨¡åž‹èƒ½å¤Ÿæ›´å¥½åœ°å¤„ç†**é•¿æ–‡æ¡£æ‘˜è¦ã€å¤šè½®å¯¹è¯**ç­‰éœ€è¦é•¿ä¸Šä¸‹æ–‡ç†è§£çš„ä»»åŠ¡ï¼Œæœ‰æ•ˆç¼“è§£äº†ä¼ ç»Ÿä½ç½®ç¼–ç çš„é•¿åº¦å¤–æŽ¨é—®é¢˜ã€‚

æ­¤å®žçŽ°ä»£è¡¨äº†RoPEæŠ€æœ¯çš„æœ€æ–°å‘å±•æ–¹å‘ï¼Œé€šè¿‡å¼•å…¥åŠ¨æ€è°ƒæ•´æœºåˆ¶ï¼Œåœ¨ä¿æŒåŽŸæœ‰ä¼˜ç‚¹çš„åŒæ—¶æ˜¾è‘—æå‡äº†é•¿åºåˆ—å¤„ç†èƒ½åŠ›ã€‚

## 3.1 - apply_rotary_emb

è¿™ä¸ª `apply_rotary_emb` å‡½æ•°æ˜¯å®žçŽ°**æ—‹è½¬ä½ç½®ç¼–ç **çš„æ ¸å¿ƒæ“ä½œï¼Œå®ƒé€šè¿‡å¤æ•°ä¹˜æ³•å°†ä½ç½®ä¿¡æ¯å·§å¦™åœ°æ³¨å…¥åˆ°è¾“å…¥å¼ é‡ä¸­ã€‚ä¸‹é¢æˆ‘æ¥è¯¦ç»†è§£æžå®ƒçš„æ¯ä¸€æ­¥ã€‚

### å‡½æ•°å‚æ•°ä¸Žç›®æ ‡
- **è¾“å…¥å¼ é‡ `x`**ï¼šé€šå¸¸æ˜¯Transformerä¸­çš„**æŸ¥è¯¢æˆ–é”®**ï¼Œå½¢çŠ¶ä¸º `(batch_size, seq_len, ..., head_dim)`ã€‚
- **ä½ç½®ç¼–ç  `freqs_cis`**ï¼šç”± `precompute_freqs_cis` é¢„è®¡ç®—ï¼ŒåŒ…å«æ¯ä¸ªä½ç½®å¯¹åº”çš„å¤æ•°æ—‹è½¬å› å­ã€‚
- **æ ¸å¿ƒç›®æ ‡**ï¼šè®© `x` çš„æ¯ä¸ªç‰¹å¾ç»´åº¦æ ¹æ®å…¶ä½ç½®è¿›è¡Œæ—‹è½¬ï¼Œä»Žè€Œä½¿ç‚¹ç§¯æ³¨æ„åŠ›èƒ½è‡ªç„¶æºå¸¦ç›¸å¯¹ä½ç½®ä¿¡æ¯ã€‚

```python
def apply_rotary_emb(x: torch.Tensor, freqs_cis: torch.Tensor) -> torch.Tensor:
    dtype = x.dtype
    x = torch.view_as_complex(x.float().view(*x.shape[:-1], -1, 2))
    freqs_cis = freqs_cis.view(1, x.size(1), 1, x.size(-1))
    y = torch.view_as_real(x * freqs_cis).flatten(3)
    return y.to(dtype)
```
