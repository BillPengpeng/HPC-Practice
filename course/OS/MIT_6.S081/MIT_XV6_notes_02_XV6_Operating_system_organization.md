本文主要整理Chapter 2 Operating system organization的要点。

## 前言

本章阐述了操作系统核心目标（多任务处理、进程隔离、可控交互）的实现框架，并以 xv6 系统为例介绍其在 RISC-V 硬件上的具体设计。

**关键要点总结：**

1.  **操作系统的三大核心需求：**
    *   **多路复用 (Multiplexing)：** 必须管理并发活动（进程），高效时分复用硬件资源（如 CPU），即使在进程数超过物理 CPU 核心数时也能保证每个进程都有执行机会。
    *   **隔离 (Isolation)：** 必须确保进程间隔离性。一个进程的故障（Bug 或崩溃）不应影响与之无关的其他进程，保证系统稳定性。
    *   **交互 (Interaction)：** 必须在提供隔离的同时，支持进程间安全、可控的通信（如管道 Pipe），满足协作需求。*完全隔离不可行*。

2.  **xv6 作为具体实例：**
    *   **设计焦点：** 文本以 **xv6** 操作系统为实例，重点阐述其采用 **单体内核 (Monolithic Kernel)** 的设计（这也是 Unix 系 OS 的主流架构）如何满足上述三大需求。
    *   **核心单元：** **进程 (Process)** 是 xv6 中实现隔离的基本单位。
    *   **启动关键：** 系统启动时会创建**第一个初始进程**。

3.  **xv6 的硬件与实现基础：**
    *   **硬件平台：** 运行于 **多核 (Multi-core) RISC-V 微处理器** 上。其低层功能（如进程实现）是 RISC-V 特有的。
    *   **CPU 特性：** RISC-V 是 **64 位** CPU 架构。
    *   **编程模型：** xv6 采用 **“LP64” C 语言**编写：
        *   `long` (L) 和 指针 (P) 为 64 位。
        *   `int` 为 32 位。
    *   **参考文档：** 读者需参考 **RISC-V 用户级 ISA** 和 **特权架构** 规范文档（或推荐书籍《The RISC-V Reader》）。

4.  **运行环境硬件：**
    *   **模拟环境：** xv6 针对 **QEMU “-machine virt”** 模拟的硬件平台开发。
    *   **硬件组成：** 该模拟环境包含：
        *   **RAM (内存)**
        *   **ROM (包含引导代码)**
        *   连接用户键盘/屏幕的 **串行接口**
        *   用于存储的 **磁盘**。

## 2.1 Abstracting physical resources

本章节探讨了操作系统为何必须通过抽象（而非直接暴露硬件资源）来管理物理资源，核心目的在于解决**强隔离性**需求，同时兼顾程序员的便利性。Unix 的系统调用接口是实现这种抽象的典范。

**关键要点总结：**

1.  **核心问题：为什么需要操作系统？**
    *   **替代方案：** 理论上可将系统调用实现为**库函数**，由应用程序直接链接使用。这样应用可自由定制、高效访问硬件资源（性能/实时性好）。某些嵌入式或实时系统采用此方式。
    *   **库方案的缺点：** 仅适用于应用间**高度信任、无缺陷**的场景。它需要应用**主动协作（Cooperative）** （如定期让出CPU），这在多应用环境下存在风险（应用可能不协作、有Bug）。

2.  **强隔离性需求的驱动：**
    *   现实场景中，应用通常**互不信任**且**可能存在缺陷**，因此需要比协作式更强的隔离保障。
    *   **核心实现手段：**
        *   **禁止直接访问：** 禁止应用程序直接操作敏感硬件资源（CPU、磁盘、物理内存）。
        *   **资源抽象为服务：** 将硬件资源**抽象**为操作系统提供的、定义良好的**服务接口（系统调用）**。

3.  **抽象带来的核心价值：**
    *   **强隔离：** 确保单个应用的故障（如无限循环、错误操作）不影响无关应用和整个系统。
    *   **便利性：** 为程序员提供更高级、更易用的抽象，屏蔽底层硬件复杂性。
    *   **操作系统控制权：** OS 作为接口实现者，统一管理资源分配、错误处理等。

4.  **Unix 抽象的关键实例：**
    *   **文件系统 (替代直接磁盘访问)：**
        *   应用通过 `open`, `read`, `write`, `close` 操作文件。
        *   **价值：** 提供路径名、权限管理、数据组织便利性；OS 统一管理磁盘空间。
    *   **进程调度 & 透明上下文切换 (替代直接管理CPU)：**
        *   OS 透明地在进程间切换硬件 CPU，自动保存/恢复寄存器状态。
        *   **价值：** 应用无需感知时间分片；OS 即使面对无限循环应用也能共享 CPU。
    *   **`exec` (替代直接管理物理内存)：**
        *   进程通过 `exec` 加载内存镜像。
        *   **价值：** OS 决定进程内存布局；可实现内存不足时的磁盘交换（如换页）；利用文件系统方便存储程序镜像。
    *   **文件描述符 (统一交互机制)：**
        *   作为进程间通信（如管道）和资源访问的统一接口。
        *   **价值：**
            *   抽象了底层细节（如管道数据存储位置）。
            *   简化交互语义（如管道前序进程失败，内核自动生成EOF信号给后续进程）。

## 2.2 User mode, supervisor mode, and system calls

本章节阐述了实现应用程序**强隔离性**的关键机制——依托于 CPU 硬件提供的**特权模式**和受控的**用户态-内核态转换**。

**关键要点总结：**

1.  **强隔离的核心目标：**
    *   确保**单个应用程序的错误或故障**（如越界访问、非法指令） **不会**：
        *   导致**操作系统本身崩溃**。
        *   影响**其他无关应用程序**的正常运行。
    *   操作系统必须能**清理失败应用**的资源并继续运行。
    *   **具体隔离要求：**
        *   禁止应用**修改/读取**操作系统的数据结构和指令。
        *   禁止应用**访问其他进程**的内存空间。

2.  **硬件基础：CPU特权模式 (以RISC-V为例)：**
    *   CPU指令执行分为**三种模式**，权限逐级递减：
        *   **机器模式 (Machine Mode)：**
            *   拥有**最高权限**（完全特权），CPU启动时默认为此模式。
            *   主要职责：**引导启动**，进行初步硬件设置。
            *   *xv6用法*：执行少量初始化代码后立即切换到监管者模式。
        *   **监管者模式 (Supervisor Mode)：**
            *   允许执行**特权指令** (如开关中断、读写页表基址寄存器)。
            *   操作系统**内核**运行在此模式。
        *   **用户模式 (User Mode)：**
            *   仅允许执行**非特权指令**（常规计算指令）。
            *   普通**应用程序**运行在此模式。
    *   **术语对应关系：**
        *   用户模式 → 用户空间 (User Space)
        *   监管者模式 → 内核空间 (Kernel Space)
        *   监管者模式软件 → 内核 (Kernel)

3.  **用户态-内核态转换机制（系统调用入口控制）：**
    *   **核心限制：** 应用**无法直接调用**内核函数。
    *   **受控入口点：** CPU提供**专用指令**实现模式转换和进入内核（RISC-V：`ecall`）。
    *   **转换过程：**
        1.  应用执行 `ecall`（请求系统调用）。
        2.  CPU **自动**从用户模式切换到监管者模式。
        3.  CPU 跳转到由**内核预先设定好的固定入口点**执行（*关键*：入口点由内核指定，应用不能选择）。
    *   **内核的职责（入口点后续处理）：**
        *   **参数验证：** 严格检查用户传入的参数合法性（如地址是否属于用户进程）。
        *   **权限检查：** 判断用户程序是否有权执行所请求的操作（如是否有权限写入指定文件）。
        *   **执行或拒绝：** 根据验证和检查结果，执行操作或拒绝请求并返回错误。
    *   **强制控制入口点的原因：** 防止恶意程序绕过内核的**安全检查机制**（如直接跳转到跳过参数验证的代码点）。

## 2.3 Kernel organization

本章节探讨了操作系统的核心设计问题——**内核应包含哪些组件？** 重点对比了**宏内核（Monolithic Kernel）** 和 **微内核（Microkernel）** 两种架构的优劣、适用场景及现实权衡，最终说明 xv6 采用宏内核设计的合理性。

---

### **关键要点总结**

1. **宏内核架构（Monolithic Kernel）**  
   - **设计理念**：整个操作系统（包括所有系统调用实现）运行在内核态（Supervisor Mode）。  
   - **优势**：  
     - **开发便利性**：无需划分特权边界，各子系统（如文件系统、虚拟内存）可紧密协作（例如共享缓冲区缓存）。  
     - **高性能**：内核内部调用无上下文切换开销（如 Linux 的高性能源于此）。  
   - **劣势**：  
     - **可靠性风险**：内核任何模块的缺陷（如空指针错误）可能导致整个系统崩溃（需重启）。  
     - **复杂性高**：子系统间交互复杂，增加出错概率。  

   **典型系统**：大多数 Unix 系统（如 Linux、xv6），Windows NT（混合型但偏宏内核）。

2. **微内核架构（Microkernel）**  
   - **设计理念**：最小化内核代码（仅保留核心功能：进程调度、IPC、硬件抽象），其他服务（如文件系统、网络）以 **用户态服务器进程** 运行。  
   - **优势**：  
     - **高可靠性**：内核更小，错误概率低；服务进程崩溃不影响内核及其他服务。  
     - **安全可验证性**：小内核便于形式化验证（如 seL4 验证内存安全）。  
   - **劣势**：  
     - **性能开销**：服务间通过 **IPC 消息传递** 通信，上下文切换频繁（例如文件操作需 shell → 文件服务器 → 内核交互）。  
     - **开发复杂性**：需精心设计进程间通信机制。  

   **典型系统**：Minix、QNX、L4（嵌入式/实时系统）。

3. **现实中的权衡与混合实践**  
   - **无绝对优劣**：选择取决于设计目标：  
     - **性能优先** → 宏内核（如 Linux 对计算密集型应用的优势）。  
     - **安全/可靠性优先** → 微内核（如嵌入式设备中的 QNX）。  
   - **混合架构普遍**：  
     - Linux 虽是宏内核，但部分功能（GUI 服务）运行在用户态。  
     - 某些微内核为性能将关键服务移回内核态（如文件系统）。  
   - **演进阻力**：成熟系统（如 Linux）无充分动力重构为纯微内核，新特性优先于架构改造。

4. **xv6 的设计选择**  
   - 采用 **宏内核架构**（与大多数 Unix 一致），提供完整操作系统接口。  
   - 内核虽小（因功能精简），**本质仍是宏内核**：所有系统服务在内核态实现，无用户态服务进程。  

---

### **核心共识**
- **架构差异不影响共性基础**：两种架构均需实现 **系统调用、页表管理、中断处理、进程调度、锁机制、文件系统** 等核心功能。  
- **教材聚焦核心概念**：本书重点讲解这些通用机制（而非架构争论），xv6 作为教学载体服务于该目标。

## 2.5 Process overview

本章节详细阐述了 **进程** 作为 xv6（及类 Unix 系统）**核心隔离单元**的抽象机制，重点描述了其如何通过硬件（页表）与软件（内核状态）的协同，为每个进程提供 **私有内存空间** 和 **独占 CPU 执行流** 的**安全隔离环境**。
---

### **关键要点总结**

```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
```

1.  **进程的核心目标：强隔离性**  
    *   防止进程破坏/窥探其他进程的**内存、CPU、文件描述符**等资源。
    *   防止进程破坏**内核自身**或颠覆其隔离机制（内核需抵御有缺陷或恶意进程的攻击）。
    *   **实现核心机制**：用户/监管者模式位 (Mode Bit)、地址空间 (Address Spaces)、线程时间片调度 (Time-slicing)。

2.  **进程的“私有机器”抽象**  
    *   **私有地址空间**：每个进程拥有独立且受保护的虚拟内存空间 (`p->pagetable`)，其他进程无法读写。
    *   **独占 CPU 执行流**：进程感知到其独占地在执行其指令（通过**线程**实现）。

3.  **地址空间与页表 (Page Table)**  
    *   **硬件基础**：RISC-V **页表硬件**自动将**虚拟地址** (指令操作) 转换为**物理地址** (访问内存)。
    *   **独立页表**：xv6 为每个进程维护**独立页表** (`p->pagetable`)，定义其地址空间布局：
        *   **用户内存区** (从虚拟地址 `0` 开始)：包含代码段、全局变量、用户栈、堆区（`malloc` 动态扩展）。
        *   **内核保留区** (地址空间顶端)：包含 **trampoline 页**（用户/内核态转换代码）和 **trapframe 页**（保存用户寄存器状态）。
    *   **地址空间限制**：受限于 64 位指针、硬件使用的 39 位虚拟地址和 xv6 实际使用的 **38 位**（最大地址 `MAXVA = 0x3fffffffff`）。

4.  **线程 (Thread) 与执行控制**  
    *   **线程定义**：代表进程的**执行流**，包含执行所需的上下文状态。
    *   **线程状态**：可在 CPU 上**执行**或**挂起**（保存状态，后续可恢复）。
    *   **上下文切换**：内核通过**保存/恢复线程状态**在进程间切换 CPU。
    *   **双栈设计**：
        *   **用户栈**：进程执行**用户态指令**时使用。
        *   **内核栈** (`p->kstack`)：进程**进入内核**（系统调用/中断）时使用，执行内核代码。
        *   **设计价值**：保护内核执行不依赖用户栈（即使后者损坏）。

5.  **用户态/内核态转换机制**  
    *   **进入内核**：用户进程通过 `ecall` 指令触发（**提升特权级**，跳转至**内核固定入口点**）。
        *   入口代码切换到该进程的**内核栈**并执行**系统调用服务**。
    *   **参数与权限检查**：内核严格验证系统调用参数（如地址合法性）和操作权限。
    *   **返回用户态**：内核调用 `sret` 指令（**降低特权级**），恢复用户栈并继续执行 `ecall` 后指令。
    *   **阻塞机制**：内核态线程可**主动阻塞**等待 I/O，完成后恢复执行。

6.  **进程内核状态管理 (struct proc)**  
    *   **核心状态成员**：
        *   `p->state`：进程状态（如就绪、运行中、等待I/O、退出）。
        *   `p->pagetable`：**进程页表指针**，告知硬件使用该页表进行用户地址转换。
        *   `p->kstack`：**内核栈指针**。
    *   **页表额外作用**：记录分配给该进程的**物理页帧地址**。

7.  **进程的本质抽象**  
    *   **两个核心思想**：
        *   **地址空间** → 提供 **“私有内存”** 的假象。
        *   **线程** → 提供 **“独占CPU”** 的假象。
    *   **xv6 实现**：**一个进程 = 一个地址空间 + 一个线程**。
    *   **现代扩展**：真实系统（如 Linux）常支持**多线程进程**以利用多核 CPU（xv6 为简化未实现）。

## 2.6 Code: starting xv6, the first process and system call

本章节详细描述了 xv6 内核从**硬件上电**到**首个用户进程**（`/init`）启动的完整流程，揭示了操作系统如何通过阶梯式的**特权级切换**和**初始化过程**，最终构建出用户空间的运行环境。

---

### **关键要点总结**

1. **硬件启动与引导加载**  
   *   **上电初始化**：RISC-V CPU 启动后进入**机器模式 (Machine Mode)**，执行 ROM 中的**引导加载程序 (Boot Loader)**。  
   *   **内核加载**：引导加载程序将 xv6 内核镜像加载到**物理地址 `0x80000000`**（避免覆盖 `0x0:0x80000000` 的 I/O 设备地址空间）。  
   *   **初始执行**：CPU 从入口点 `_entry` (kernel/entry.S) 开始执行，此时**分页硬件尚未启用**（虚拟地址=物理地址）。  

```c
# 此代码会被​​所有CPU核心并行执行​
.section .text
.global _entry
_entry:
        # set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0     # 将stack0的基础地址加载到栈指针sp
        li a0, 1024*4     # 加载立即数4096（4KB）到a0（每个CPU的栈大小）
        csrr a1, mhartid  # 读取当前CPU核心ID（mhartid寄存器）到a1
        addi a1, a1, 1    # 将核心ID+1（偏移计算，避免hart0从地址0开始）
        mul a0, a0, a1    # 计算当前CPU的栈偏移：4096 * (hartid + 1)
        add sp, sp, a0    # 设置当前CPU的SP = stack0 + 4096*(hartid+1)
        # jump to start() in start.c
        call start
spin:
        j spin            # 无限循环（安全防护）
```

2. **内核早期初始化（机器模式）**  
   *   **栈设置**：`_entry` 为内核 C 代码运行设置**初始栈空间 `stack0`**，栈指针 `sp` 指向栈顶 (`stack0+4096`)。  
   *   **跳转至 C 代码**：`_entry` 调用 C 函数 `start()` (kernel/start.c)。  

3. **切换至监管者模式 (Supervisor Mode)**  
   *   **关键配置**：`start()` 在机器模式下完成仅允许该模式的操作（如配置时钟中断）。  
   *   **“伪装”返回监管者模式**：通过 `mret` 指令实现模式切换：  
       *   在 `mstatus` 寄存器设置**先前特权级为监管者模式**。  
       *   将 `main()` 函数地址写入 `mepc`（“返回”地址）。  
       *   将 `satp` 页表寄存器置 `0`（**禁用监管者模式虚拟地址转换**）。  
       *   **委托所有中断/异常**给监管者模式处理。  
   *   **进入内核主函数**：执行 `mret` 后，PC 跳转到 `main()` (kernel/main.c)。  

```c
// entry.S jumps here in machine mode on stack0.
void start()
{
  // 1. 设置 mret 返回后的特权模式为监管者模式 (Supervisor)
  unsigned long x = r_mstatus();      // 读取 mstatus 寄存器
  x &= ~MSTATUS_MPP_MASK;             // 清除 MPP（Machine Previous Privilege）位
  x |= MSTATUS_MPP_S;                 // 设置 MPP 为监管者模式 (1)
  w_mstatus(x);                       // 写回 mstatus

  // 2. 设置 mret 返回地址为 main() 函数
  w_mepc((uint64)main);               // 将 main 函数地址存入 mepc（Machine Exception PC）

  // 3. 暂时禁用监管者模式的分页机制
  w_satp(0);                          // 页表寄存器清零 = 禁用 MMU

  // 4. 委托所有中断和异常给监管者模式处理
  w_medeleg(0xffff);                  // 委托所有异常（同步事件）
  w_mideleg(0xffff);                  // 委托所有中断（异步事件）
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // 启用监管者模式的外部/时钟/软件中断

  // 5. 配置物理内存保护（PMP）允许监管者模式访问全物理内存
  w_pmpaddr0(0x3fffffffffffffull);    // 设置地址范围：0 ~ 最大物理地址
  w_pmpcfg0(0xf);                     // R/W/X权限全开（无限制）

  // 6. 配置时钟中断
  timerinit();                        // 初始化定时器并启用时钟中断

  // 7. 将当前CPU核心ID存入tp寄存器（供cpuid()使用）
  int id = r_mhartid();               // 读取当前CPU核心ID
  w_tp(id);                           // 存入tp寄存器（线程指针）

  // 8. 切换到监管者模式并跳转到main()
  asm volatile("mret");               // 关键模式切换指令
}
```

4. **内核主初始化 (`main()`)**  
   *   **设备与子系统初始化**：初始化必要的硬件设备和内核子系统（如进程管理、内存管理）。  
   *   **创建首个进程**：调用 `userinit()` (kernel/proc.c) **创建第一个用户进程**。  

```c
// start() jumps here in supervisor mode on all CPUs.
void main() {
  // 区分引导核心（core0）和其他核心
  if(cpuid() == 0) { // 只有引导核心执行此部分
    // ============= 初始化关键内核子系统 =============
    consoleinit();   // 初始化控制台设备（串口/显示器）
    printfinit();    // 初始化内核打印系统
    printf("\nxv6 kernel is booting\n\n"); // 启动标语
    
    kinit();         // 初始化物理页帧分配器（空闲链表）
    kvminit();       // 创建内核页表（恒等映射 + I/O设备映射）
    kvminithart();   // 加载内核页表到satp寄存器（启用分页）
    
    procinit();      // 初始化进程表（分配proc结构）
    trapinit();      // 设置陷阱处理向量（中断/异常入口）
    trapinithart();  // 配置当前核心的陷阱寄存器
    
    plicinit();      // 初始化中断控制器（PLIC）
    plicinithart();  // 配置当前核心的中断委托
    
    binit();         // 初始化块设备缓存（磁盘缓存）
    iinit();         // 初始化inode缓存（文件系统元数据）
    fileinit();      // 初始化文件描述符表
    
    virtio_disk_init(); // 初始化虚拟磁盘驱动
    
    // ============= 创建第一个用户进程 =============
    userinit();      // 创建并运行第一个用户进程（init）
    
    // 同步多核启动状态
    __sync_synchronize(); // 内存屏障（确保写入顺序）
    started = 1;     // 标记全局初始化完成
  } else {           // 其他核心（非core0）执行此部分
    // 等待引导核心完成初始化
    while(started == 0) ; // 自旋等待started标志
    __sync_synchronize(); // 内存屏障（同步内存视图）
    
    printf("hart %d starting\n", cpuid()); // 打印核心启动信息
    
    // 配置当前核心专属资源
    kvminithart();   // 加载内核页表（共享core0创建的页表）
    trapinithart();  // 配置陷阱寄存器
    plicinithart();  // 配置中断委托
  }

  // ============= 所有核心最终归宿 =============
  scheduler();       // 进入调度器循环（永不返回）
}
```

5. **第一个进程的创建与执行**  
   *   **执行微型程序 (`initcode.S`)**：第一个进程运行一段**内置于内核**的 RISC-V 汇编程序 `initcode.S` (user/initcode.S)。  
   *   **触发第一个系统调用**：  
       *   `initcode.S` 将 `SYS_EXEC`（`exec` 系统调用号）存入寄存器 `a7`。  
       *   执行 `ecall` **进入内核**。  
   *   **执行 `exec` 系统调用**：  
       *   内核根据 `a7` 中的系统调用号，通过**系统调用表**找到 `sys_exec()` 并执行。  
       *   `exec` **替换当前进程内存和寄存器**为新的程序镜像：`/init` (user/init.c)。  

```c
# Initial process that execs /init.
# This code runs in user space.
#include "syscall.h"          # 包含系统调用号定义（如SYS_exec）

# exec(init, argv)
.globl start
start:                        # 用户空间入口点
        la a0, init           # a0 = init字符串地址（参数1：执行文件路径）
        la a1, argv           # a1 = argv数组地址（参数2：命令行参数数组）
        li a7, SYS_exec       # a7 = 系统调用号 SYS_exec（在syscall.h定义，值为7）
        ecall                 # 执行系统调用（关键：切换到内核态处理exec）

# for(;;) exit();             # 死循环退出（exec失败时执行）
exit:
        li a7, SYS_exit       # a7 = 系统调用号 SYS_exit（值为1）
        ecall                 # 执行exit系统调用
        jal exit              # 死循环调用（避免ecall意外返回后继续执行）

# char init[] = "/init\0";    # 初始化程序路径字符串
init:
  .string "/init\0"          # C格式字符串（包含结尾空字符）

# char *argv[] = { init, 0 }; # 命令行参数数组
.p2align 2                   # 按4字节对齐（64位系统要求）
argv:
  .quad init                 # 参数0：指向init字符串（相当于argv[0]）
  .quad 0                    # 参数1：空指针（标记数组结束）
```

6. **用户空间的初始化 (`/init`)**  
   *   **控制台设置**：`/init` 程序创建并打开**控制台设备文件**，将其作为标准输入/输出/错误（文件描述符 0, 1, 2）。  
   *   **启动 Shell**：`/init` **启动 Shell** (/bin/sh) 运行在控制台上。  
   *   **系统启动完成**：至此，xv6 操作系统**完成引导**，用户可通过 Shell 与系统交互。  

```c
int main(void) {
  int pid, wpid;

  // === 第1步：确保控制台设备可用 ===
  if(open("console", O_RDWR) < 0){  // 尝试以读写方式打开控制台
    mknod("console", CONSOLE, 0);   // 创建设备文件（主设备号CONSOLE）
    open("console", O_RDWR);        // 再次尝试打开
  }

  // === 第2步：设置标准输入/输出/错误 ===
  dup(0);  // 复制fd 0 → fd 1 (stdout)
  dup(0);  // 复制fd 0 → fd 2 (stderr)

  // === 主循环：启动和管理Shell ===
  for(;;) {
    // 启动Shell提示
    printf("init: starting sh\n");

    // 创建子进程（可能用于运行Shell）
    pid = fork();
    if(pid < 0) {  // fork失败处理
      printf("init: fork failed\n");
      exit(1);
    }

    // === 子进程分支 ===
    if(pid == 0) {
      exec("sh", argv);  // 尝试执行Shell程序（/bin/sh）
      // 若exec失败才会执行后续代码
      printf("init: exec sh failed\n"); 
      exit(1);
    }

    // === 父进程分支 ===
    // Shell监控循环
    for(;;) {
      // 等待任意子进程退出（包括Shell和孤儿进程）
      wpid = wait((int *)0);  // 不关心退出状态
      
      if(wpid == pid) {
        // 退出的正是Shell进程 → 重启Shell
        printf("init: shell exited, restarting...\n");
        break;  // 跳出内层循环，重新启动Shell
      } 
      else if(wpid < 0) {
        // wait系统调用错误
        printf("init: wait returned an error\n");
        exit(1);
      } 
      else {
        // 其他孤儿进程退出 → 静默回收资源
        // （无操作）
      }
    }
  }
}
```

---

### **核心流程图示**  
```  
硬件上电 → Boot Loader (ROM) → 加载内核至 0x80000000 → _entry (机器模式) → 栈初始化 → start() (机器模式)  
↓  
mret "伪装返回" → main() (监管者模式) → 设备初始化 → userinit() → 创建第一个进程 (执行 initcode.S)  
↓  
initcode.S 执行 ecall (SYS_EXEC) → 内核处理 exec → 替换为 /init 程序 → init 设置控制台 → 启动 Shell → 系统就绪  
```

## 2.7 Security Model

本章节阐述了操作系统安全设计的**核心假设与目标**，揭示了“**用户代码不可信，内核代码可信**”的基础安全范式，同时探讨了理想设计与现实挑战之间的差距。

---

### **关键要点总结**

#### **1. 安全威胁模型（用户代码的恶意性）**
- **核心假设**：用户代码（应用）会**竭尽全力破坏系统**，包括：
  - 越界内存访问（读写非法地址）
  - 执行特权指令（如直接操作控制寄存器）
  - 非法硬件访问（绕过内核直接操作设备）
  - 精心构造恶意系统调用参数（诱骗内核崩溃或越权）
- **攻击目标**：破坏内核或其他进程的隔离性

#### **2. 内核的安全设计目标**
- **绝对隔离原则**：限制进程**仅能**：
  - 访问自身用户内存（读/写/执行）
  - 使用32个通用寄存器
  - 通过**合法系统调用**影响系统（严格参数校验）
- **零容忍机制**：阻止任何超出上述范围的操作

#### **3. 内核代码的信任假设**
- **开发前提**：内核代码由**善意的专业开发者**编写
  - 预期无恶意代码（如后门）
  - 预期极少缺陷（理想化“零漏洞”）
- **内部协作信任**：
  - 内核函数（如自旋锁）需**正确使用**
  - 数据结构和接口规则被严格遵守
- **硬件信任**：CPU/RAM/磁盘等严格遵循规格说明

#### **4. 现实挑战与安全增强**
- **资源耗尽攻击**：恶意程序可耗尽：
  - 磁盘空间、CPU时间、进程槽位 → 导致系统不可用
- **漏洞不可避免性**：
  - 内核/硬件必然存在未知漏洞（如Linux漏洞持续被发现）
  - 恶意用户会利用漏洞绕过隔离（**安全假设被打破**）
- **纵深防御实践**：
  - 断言检查（Assertions）
  - 类型安全机制
  - 栈保护页（Stack Guard Pages）
  - 代码审计与形式化验证（如seL4）
- **特权边界模糊化**：
  - 部分用户进程提供关键服务（如设备管理）
  - 可加载内核模块（LKM）使用户代码进入内核（Linux）

---

### **核心矛盾与设计启示**
| **理想模型** | **现实约束** |
|-------------|-------------|
| 用户程序完全隔离 | 资源耗尽攻击无法避免 |
| 内核绝对可信 | 内核漏洞持续被发现 |
| 硬件行为符合文档 | 硬件缺陷（如熔断漏洞）存在 |
| **设计启示**：安全是持续过程，需通过**分层防御**和**漏洞缓解**平衡性能与安全 |

