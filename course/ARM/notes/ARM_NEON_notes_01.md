NEON 是 ARM 架构的 SIMD（单指令多数据）扩展，适用于加速图像处理、信号处理、机器学习等计算密集型任务。

### 1. NEON 基础数据类型
NEON 数据类型格式为 `{类型}{位数}x{通道数}_t`，例如：

| **数据类型**      | **说明**                          | **寄存器位宽** | **典型应用场景**          |
|--------------------|-----------------------------------|----------------|---------------------------|
| `int8x8_t`         | 8 个 8 位有符号整数               | 64 位          | 图像像素处理（如灰度值）  |
| `uint8x16_t`       | 16 个 8 位无符号整数              | 128 位         | RGB 图像数据、文本处理    |
| `int16x4_t`        | 4 个 16 位有符号整数              | 64 位          | 音频处理（16 位采样）     |
| `uint16x8_t`       | 8 个 16 位无符号整数              | 128 位         | 图像处理（如 RGB565）     |
| `int32x2_t`        | 2 个 32 位有符号整数              | 64 位          | 大整数运算、坐标计算      |
| `uint32x4_t`       | 4 个 32 位无符号整数              | 128 位         | 大规模整数运算            |
| `float32x2_t`      | 2 个 32 位单精度浮点数            | 64 位          | 轻量浮点运算（移动端）    |
| `float32x4_t`      | 4 个 32 位单精度浮点数            | 128 位         | 矩阵乘法、3D 图形计算     |

| **数据类型**          | **说明**                          | **典型应用场景**          |
|------------------------|-----------------------------------|---------------------------|
| `uint8x16x2_t`         | 2 个 128 位向量（每向量 16 字节） | YUV 双通道图像处理        |
| `uint8x16x3_t`         | 3 个 128 位向量                   | RGB 三通道像素处理        |
| `uint8x16x4_t`         | 4 个 128 位向量                   | RGBA 四通道像素处理       |

```
// 加载 RGB 图像数据
// 假设图像数据为 RGB888 格式，每像素 3 字节
uint8_t *rgb_data = ...;
uint8x16x3_t rgb_vec = vld3q_u8(rgb_data);

// 分离 R、G、B 通道
uint8x16_t r = rgb_vec.val[0];
uint8x16_t g = rgb_vec.val[1];
uint8x16_t b = rgb_vec.val[2];

// 存储 YUV 双通道数据
uint8_t *yuv_data = ...;
uint8x16x2_t yuv_vec;
yuv_vec.val[0] = y_channel; // Y 分量
yuv_vec.val[1] = uv_channel; // UV 分量
vst2q_u8(yuv_data, yuv_vec);
```

### 2. NEON 基本函数

#### 2.1 命名规则
NEON 函数名一般遵循以下格式：
```
v{操作}{模式}{q}_{类型}
```
- **操作**：如 `ld`（加载）、`st`（存储）、`add`（加法）、`mul`（乘法）等。
- **模式**：数字（1、2、3、4）表示 **通道数** 或 **结构体解包模式**。
- **q**：表示使用 **128 位寄存器**（四字，Quad-word），无 `q` 则为 64 位寄存器（双字，Double-word）。
- **类型**：数据类型（如 `f32`、`s16`、`u8` 等）。

##### 数字（1、2、3、4）的含义
数字表示 **数据在内存中的排列模式**，具体如下：

**模式 `1`（连续模式）**
- **作用**：连续加载/存储数据，不进行通道分离。
- **示例**：
  - `vld1q_f32(ptr)`：从 `ptr` 连续加载 4 个 float（128 位）。
  - `vst1q_s16(ptr, vec)`：将 8 个 int16 连续存储到 `ptr`。

**模式 `2`（双通道交错模式）**
- **作用**：将数据视为 **结构体数组**，按双通道交替加载/存储。
- **适用场景**：处理交错的 RGB565、YUV 双通道数据。
- **示例**：
  ```c
  uint8x16x2_t vec = vld2q_u8(ptr);  // 加载 32 字节，拆分为 2 个 128 位向量
  ```
  - 输入内存布局：`[a0, b0, a1, b1, ..., a15, b15]`
  - 输出向量：
    - `vec.val[0] = [a0, a1, ..., a15]`
    - `vec.val[1] = [b0, b1, ..., b15]`

**模式 `3`（三通道交错模式）**
- **作用**：将数据视为 **三通道结构体数组**（如 RGB 像素）。
- **示例**：
  ```c
  uint8x16x3_t vec = vld3q_u8(ptr);  // 加载 48 字节，拆分为 3 个 128 位向量
  ```
  - 输入内存布局：`[R0, G0, B0, R1, G1, B1, ..., R15, G15, B15]`
  - 输出向量：
    - `vec.val[0] = [R0, R1, ..., R15]`
    - `vec.val[1] = [G0, G1, ..., G15]`
    - `vec.val[2] = [B0, B1, ..., B15]`

**模式 `4`（四通道交错模式）**
- **作用**：处理四通道数据（如 RGBA 像素）。
- **示例**：
  ```c
  uint8x16x4_t vec = vld4q_u8(ptr);  // 加载 64 字节，拆分为 4 个 128 位向量
  ```
  - 输入内存布局：`[R0, G0, B0, A0, R1, G1, B1, A1, ...]`
  - 输出向量：
    - `vec.val[0] = [R0, R1, ..., R15]`
    - `vec.val[1] = [G0, G1, ..., G15]`
    - `vec.val[2] = [B0, B1, ..., B15]`
    - `vec.val[3] = [A0, A1, ..., A15]`

##### `q` 的含义
- **有 `q`**：操作 **128 位寄存器**（如 `float32x4_t`、`uint8x16_t`）。
- **无 `q`**：操作 **64 位寄存器**（如 `float32x2_t`、`uint8x8_t`）。

**示例对比**
| **函数**           | **寄存器宽度** | **数据量**         | **数据类型**       |
|--------------------|----------------|--------------------|--------------------|
| `vld1_u8(ptr)`     | 64 位          | 8 个 uint8         | `uint8x8_t`        |
| `vld1q_u8(ptr)`    | 128 位         | 16 个 uint8        | `uint8x16_t`       |
| `vst3_s16(ptr, v)` | 64 位 x3       | 12 个 int16        | `int16x4x3_t`      |
| `vst3q_s16(ptr, v)`| 128 位 x3      | 24 个 int16        | `int16x8x3_t`      |

**类型后缀**
| **后缀** | **数据类型**         | **示例**                     |
|----------|----------------------|------------------------------|
| `f32`    | 32 位浮点数          | `float32x4_t`                |
| `s16`    | 16 位有符号整数      | `int16x8_t`                  |
| `u8`     | 8 位无符号整数       | `uint8x16_t`                 |
| `s32`    | 32 位有符号整数      | `int32x4_t`                  |

#### 2.2 初始化函数

##### 全量初始化（Broadcast）
将 **单个标量值** 复制到向量所有元素。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vdupq_n_u8(uint8_t)`   | 创建 128 位向量，所有元素为指定 u8 值 | `uint8x16_t vec = vdupq_n_u8(255);`    |
| `vdupq_n_s16(int16_t)`  | 创建 128 位向量，所有元素为指定 s16 值| `int16x8_t vec = vdupq_n_s16(100);`    |
| `vdupq_n_f32(float)`    | 创建 128 位向量，所有元素为指定 float | `float32x4_t vec = vdupq_n_f32(1.0f);`|
| `vdup_n_u32(uint32_t)`  | 创建 64 位向量，所有元素为指定 u32 值 | `uint32x2_t vec = vdup_n_u32(0xFF);`   |

##### 加载初始化（Load & Broadcast）
从内存加载 **单个值** 并复制到向量所有元素。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vld1q_dup_u8(uint8_t*)`| 从内存加载 1 个 u8，广播到 16 个元素  | `uint8x16_t vec = vld1q_dup_u8(&val);` |
| `vld1q_dup_f32(float*)` | 从内存加载 1 个 float，广播到 4 个元素| `float32x4_t vec = vld1q_dup_f32(&f);` |

##### 组合初始化（Combine）
将多个 **低位宽向量** 组合成高位宽向量。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vcombine_u8(a, b)`     | 合并两个 64 位 u8 向量为 128 位       | `uint8x16_t = vcombine_u8(vec_low, vec_high);` |
| `vcombine_s16(a, b)`    | 合并两个 64 位 s16 向量为 128 位      | `int16x8_t = vcombine_s16(low, high);` |

##### 部分初始化（Set）
手动指定向量中每个元素的值（需注意元素顺序）。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vsetq_lane_u8(val, vec, lane)` | 设置向量指定通道的值 | `vec = vsetq_lane_u8(255, vec, 0);` |
| `vcreate_u8(uint64_t)`  | 从标量值创建 64 位向量（ARMv7）       | `uint8x8_t vec = vcreate_u8(0x1234);` |

##### 零初始化（Zero）
生成全零向量。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vdupq_n_u8(0)`         | 128 位全零 u8 向量                    | `uint8x16_t zero = vdupq_n_u8(0);`     |
| `vmovq_n_f32(0.0f)`     | 128 位全零 float 向量                 | `float32x4_t zero = vmovq_n_f32(0);`   |

##### **特殊模式初始化**
生成特定模式的向量（如递增序列、掩码等）。

| **函数**                | **作用**                              | **示例**                               |
|-------------------------|---------------------------------------|----------------------------------------|
| `vidupq_u8(uint8_t)`    | 生成递增序列（ARMv8.1+）              | `uint8x16_t = vidupq_u8(start, 1);`    |
| `vceqq_u8(a, b)`        | 生成比较结果掩码向量（相等时为 0xFF） | `mask = vceqq_u8(a, b);`              |

```
// 合并两个 64 位向量
uint8x8_t low = vdup_n_u8(0xAA);  // [0xAA, 0xAA, ..., 0xAA] (64位)
uint8x8_t high = vdup_n_u8(0x55);
uint8x16_t combined = vcombine_u8(low, high); // 前8字节 0xAA，后8字节 0x55
```

#### 2.3 数据加载与存储

##### 单元素加载（Broadcast）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld1q_dup_u8(uint8_t*)` | 加载 1 个 u8 并广播到 16 个通道  | `uint8x16_t vec = vld1q_dup_u8(ptr);` |
| `vld1q_dup_f32(float*)` | 加载 1 个 float 并广播到 4 个通道 | `float32x4_t vec = vld1q_dup_f32(&val);` |

##### 多元素连续加载
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld1q_u8(uint8_t*)`    | 加载 16 个 u8（128 位寄存器）     | `uint8x16_t vec = vld1q_u8(ptr);` |
| `vld1q_s16(int16_t*)`   | 加载 8 个 int16（128 位寄存器）   | `int16x8_t vec = vld1q_s16(src);` |
| `vld1_f32(float*)`      | 加载 2 个 float（64 位寄存器）    | `float32x2_t vec = vld1_f32(ptr);` |

##### 双通道交错加载
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld2q_u8(uint8_t*)`    | 加载 32 字节，拆分为 2 个 128 位向量 | `uint8x16x2_t vec = vld2q_u8(ptr);` |
| **内存布局**            | `[Y0, U0, Y1, U1, ..., Y15, U15]` → `vec.val[0] = Y0-Y15`, `vec.val[1] = U0-U15` | |

##### 三通道交错加载（RGB 处理）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld3q_u8(uint8_t*)`    | 加载 48 字节，拆分为 3 个 128 位向量 | `uint8x16x3_t vec = vld3q_u8(ptr);` |
| **内存布局**            | `[R0, G0, B0, R1, G1, B1, ...]` → `vec.val[0] = R0-R15`, `vec.val[1] = G0-G15`, `vec.val[2] = B0-B15` | |

#####  四通道交错加载（RGBA 处理）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld4q_u8(uint8_t*)`    | 加载 64 字节，拆分为 4 个 128 位向量 | `uint8x16x4_t vec = vld4q_u8(ptr);` |
| **内存布局**            | `[R0, G0, B0, A0, R1, G1, B1, A1, ...]` → 分离 R/G/B/A 通道 | |

##### 连续存储
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vst1q_u8(uint8_t*, uint8x16_t)` | 存储 16 个 u8 到连续内存       | `vst1q_u8(ptr, vec);`            |
| `vst1q_f32(float*, float32x4_t)` | 存储 4 个 float 到连续内存     | `vst1q_f32(dst, vec);`           |

##### 交错存储
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vst2q_s16(int16_t*, int16x8x2_t)` | 将 2 个向量交错存储为双通道数据 | `vst2q_s16(ptr, vec_pair);`       |
| `vst3q_u8(uint8_t*, uint8x16x3_t)` | 将 3 个向量交错存储为三通道数据 | `vst3q_u8(rgb_ptr, rgb_vec);`     |
| `vst4q_f32(float*, float32x4x4_t)` | 将 4 个向量交错存储为四通道数据 | `vst4q_f32(rgba_ptr, rgba_vec);`  |

##### 非对齐加载/存储
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld1q_u8_x2(uint8_t*)` | 加载 2 个连续非对齐 128 位向量    | `uint8x16x2_t vec = vld1q_u8_x2(ptr);` |
| `vst1q_u8_x2(uint8_t*, uint8x16x2_t)` | 存储 2 个非对齐向量 | `vst1q_u8_x2(ptr, vec);` |

##### 部分加载/存储
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vld1q_lane_u8(uint8_t*, uint8x16_t, int lane)` | 加载单个元素到指定通道 | `vec = vld1q_lane_u8(ptr, vec, 3);` |
| `vst1q_lane_f32(float*, float32x4_t, int lane)` | 存储单个通道到内存 | `vst1q_lane_f32(ptr, vec, 2);` |


```
// 加载 RGB 图像并分离通道
#include <arm_neon.h>

void process_rgb(uint8_t *rgb_data, int width) {
    for (int i = 0; i < width; i += 16) {
        // 加载 16 像素的 RGB 数据（48 字节）
        uint8x16x3_t rgb = vld3q_u8(rgb_data + i * 3);

        // 分离通道
        uint8x16_t r = rgb.val[0];
        uint8x16_t g = rgb.val[1];
        uint8x16_t b = rgb.val[2];

        // 处理通道数据（例如：亮度调整）
        r = vaddq_u8(r, vdupq_n_u8(10));
        g = vaddq_u8(g, vdupq_n_u8(10));
        b = vaddq_u8(b, vdupq_n_u8(10));

        // 存储回内存
        uint8x16x3_t result = {r, g, b};
        vst3q_u8(rgb_data + i * 3, result);
    }
}
```

```
// 连续加载浮点数据并计算平方和
#include <arm_neon.h>

float sum_squares(const float *data, int len) {
    float32x4_t sum = vdupq_n_f32(0.0f);
    for (int i = 0; i < len; i += 4) {
        float32x4_t vec = vld1q_f32(data + i);
        sum = vmlaq_f32(sum, vec, vec); // sum += vec * vec
    }

    // 水平相加求和
    // vadd_f32是向量间相加，vpadd_f32是向量内相加
    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));
    return vget_lane_f32(vpadd_f32(sum2, sum2), 0);
}
```

#### 2.4 算术运算

##### 加法（Addition
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vaddq_s8(a, b)`      | 两个 `int8x16_t` 向量相加           | `sum = vaddq_s8(vec1, vec2);`     |
| `vaddq_u16(a, b)`     | 两个 `uint16x8_t` 向量相加          | `sum = vaddq_u16(vec1, vec2);`    |
| `vaddq_f32(a, b)`     | 两个 `float32x4_t` 向量相加         | `sum = vaddq_f32(a, b);`          |

##### 减法（Subtraction）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vsubq_s16(a, b)`     | 两个 `int16x8_t` 向量相减           | `diff = vsubq_s16(vec1, vec2);`   |
| `vsubq_u32(a, b)`     | 两个 `uint32x4_t` 向量相减          | `diff = vsubq_u32(vec1, vec2);`   |
| `vsubq_f32(a, b)`     | 两个 `float32x4_t` 向量相减         | `diff = vsubq_f32(a, b);`         |

##### 乘法（Multiplication）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vmulq_s8(a, b)`      | 两个 `int8x16_t` 向量相乘           | `prod = vmulq_s8(vec1, vec2);`    |
| `vmulq_u16(a, b)`     | 两个 `uint16x8_t` 向量相乘          | `prod = vmulq_u16(vec1, vec2);`   |
| `vmulq_f32(a, b)`     | 两个 `float32x4_t` 向量相乘         | `prod = vmulq_f32(a, b);`         |

##### 乘加融合（Fused Multiply-Add, FMA）
将乘法和加法合并为一条指令，减少延迟，提升性能。

| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vmlaq_s16(acc, a, b)`| `acc = acc + a * b`（int16）        | `acc = vmlaq_s16(acc, a, b);`     |
| `vmlaq_f32(acc, a, b)`| `acc = acc + a * b`（float32）      | `acc = vmlaq_f32(acc, a, b);`     |
| `vmlsq_f32(acc, a, b)`| `acc = acc - a * b`（float32）      | `acc = vmlsq_f32(acc, a, b);`     |

##### 饱和运算（Saturation）
防止整数溢出，结果被限制在数据类型范围内。

| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vqaddq_s8(a, b)`     | 饱和加法（int8）                   | `sum = vqaddq_s8(a, b);`          |
| `vqsubq_u16(a, b)`    | 饱和减法（uint16）                 | `diff = vqsubq_u16(a, b);`        |
| `vqdmulhq_s16(a, b)`  | 饱和双倍乘取高半部分（int16）      | `prod = vqdmulhq_s16(a, b);`      |

##### 移位运算（Shift）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vshlq_s8(a, n)`      | 左移（int8，立即数）               | `shifted = vshlq_s8(a, 3);`       |
| `vshrq_n_u16(a, n)`   | 右移（uint16，立即数）             | `shifted = vshrq_n_u16(a, 4);`    |

##### 绝对值
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vabsq_s32(a)`        | 计算绝对值（int32）                | `abs_val = vabsq_s32(a);`         |

##### 最大值/最小值
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vmaxq_s8(a, b)`      | 逐元素取最大值（int8）             | `max_val = vmaxq_s8(a, b);`       |
| `vminq_f32(a, b)`     | 逐元素取最小值（float32）          | `min_val = vminq_f32(a, b);`      |

##### 倒数与平方根
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vrecpeq_f32(a)`      | 近似倒数（float32）                | `reciprocal = vrecpeq_f32(a);`    |
| `vrsqrteq_f32(a)`     | 近似平方根倒数（float32）          | `rsqrt = vrsqrteq_f32(a);`        |

```
#include <arm_neon.h>

// 计算两个 int16 向量的点乘（长度需为 8 的倍数）
int32_t dot_product_int16(const int16_t *a, const int16_t *b, int len) {
    int32x4_t sum = vdupq_n_s32(0);

    for (int i = 0; i < len; i += 8) {
        // 加载 8 个 int16
        int16x8_t vec_a = vld1q_s16(a + i);
        int16x8_t vec_b = vld1q_s16(b + i);

        // 扩展为 int32 并相乘
        int32x4_t prod_low = vmull_s16(vget_low_s16(vec_a), vget_low_s16(vec_b));
        int32x4_t prod_high = vmull_s16(vget_high_s16(vec_a), vget_high_s16(vec_b));

        // 累加
        sum = vaddq_s32(sum, prod_low);
        sum = vaddq_s32(sum, prod_high);
    }

    // 水平相加求和
    return vgetq_lane_s32(sum, 0) + vgetq_lane_s32(sum, 1) + 
           vgetq_lane_s32(sum, 2) + vgetq_lane_s32(sum, 3);
}
```

#### 2.5 逻辑与移位运算

##### 按位与（AND）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vandq_u8(a, b)`      | 两个 `uint8x16_t` 向量按位与        | `masked = vandq_u8(vec, mask);`   |
| `vandq_s32(a, b)`     | 两个 `int32x4_t` 向量按位与         | `result = vandq_s32(a, b);`       |

##### 按位或（OR）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vorrq_u16(a, b)`     | 两个 `uint16x8_t` 向量按位或        | `combined = vorrq_u16(vec1, vec2);` |
| `vorrq_s64(a, b)`     | 两个 `int64x2_t` 向量按位或         | `result = vorrq_s64(a, b);`       |

##### 按位异或（XOR）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `veorq_u8(a, b)`      | 两个 `uint8x16_t` 向量按位异或      | `xor_result = veorq_u8(a, b);`    |
| `veorq_s16(a, b)`     | 两个 `int16x8_t` 向量按位异或       | `result = veorq_s16(a, b);`       |

##### 按位取反（NOT）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vmvnq_u32(a)`        | 对 `uint32x4_t` 向量按位取反        | `inverted = vmvnq_u32(a);`        |
| `vmvnq_s8(a)`         | 对 `int8x16_t` 向量按位取反         | `inverted = vmvnq_s8(a);`         |

##### 逻辑左移
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vshlq_u8(a, n)`      | 对 `uint8x16_t` 向量左移 n 位       | `shifted = vshlq_u8(a, 3);`       |
| `vshlq_s16(a, n)`     | 对 `int16x8_t` 向量左移 n 位        | `shifted = vshlq_s16(a, 2);`      |

##### 逻辑右移
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vshrq_n_u16(a, n)`   | 对 `uint16x8_t` 向量右移 n 位       | `shifted = vshrq_n_u16(a, 4);`    |
| `vshrq_n_s32(a, n)`   | 对 `int32x4_t` 向量右移 n 位        | `shifted = vshrq_n_s32(a, 5);`    |

##### 算术右移（带符号扩展）
| **函数**              | **作用**                            | **示例**                          |
|-----------------------|-------------------------------------|-----------------------------------|
| `vshrq_n_s16(a, n)`   | 对 `int16x8_t` 向量算术右移 n 位    | `shifted = vshrq_n_s16(a, 3);`    |

```
// 掩码生成与位操作
#include <arm_neon.h>

void bitwise_operations() {
    uint8x16_t a = vdupq_n_u8(0xAA); // [0xAA, 0xAA, ..., 0xAA]
    uint8x16_t b = vdupq_n_u8(0x55); // [0x55, 0x55, ..., 0x55]

    // 按位与
    uint8x16_t and_result = vandq_u8(a, b); // [0x00, 0x00, ..., 0x00]

    // 按位或
    uint8x16_t or_result = vorrq_u8(a, b);  // [0xFF, 0xFF, ..., 0xFF]

    // 按位异或
    uint8x16_t xor_result = veorq_u8(a, b); // [0xFF, 0xFF, ..., 0xFF]

    // 按位取反
    uint8x16_t not_result = vmvnq_u8(a);    // [0x55, 0x55, ..., 0x55]
}
```

```
// 移位操作
#include <arm_neon.h>

void shift_operations() {
    int16x8_t vec = vdupq_n_s16(0x1234); // [0x1234, 0x1234, ..., 0x1234]

    // 左移 2 位
    int16x8_t shifted_left = vshlq_n_s16(vec, 2); // [0x48D0, 0x48D0, ..., 0x48D0]

    // 右移 4 位
    int16x8_t shifted_right = vshrq_n_s16(vec, 4); // [0x0123, 0x0123, ..., 0x0123]
}
```

#### 2.6 比较与选择

##### 等于（Equal）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vceqq_u8(a, b)`        | 比较 `a == b`（uint8）            | `mask = vceqq_u8(vec1, vec2);`    |
| `vceqq_f32(a, b)`       | 比较 `a == b`（float32）          | `mask = vceqq_f32(vec1, vec2);`   |

##### 大于（Greater Than）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcgtq_s16(a, b)`       | 比较 `a > b`（int16）             | `mask = vcgtq_s16(vec1, vec2);`   |
| `vcgtq_f32(a, b)`       | 比较 `a > b`（float32）           | `mask = vcgtq_f32(vec1, vec2);`   |

##### 大于等于（Greater or Equal）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcgeq_u32(a, b)`       | 比较 `a >= b`（uint32）           | `mask = vcgeq_u32(vec1, vec2);`   |
| `vcgeq_f32(a, b)`       | 比较 `a >= b`（float32）          | `mask = vcgeq_f32(vec1, vec2);`   |

##### 小于（Less Than）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcltq_s8(a, b)`        | 比较 `a < b`（int8）              | `mask = vcltq_s8(vec1, vec2);`    |
| `vcltq_f32(a, b)`       | 比较 `a < b`（float32）           | `mask = vcltq_f32(vec1, vec2);`   |

##### 位选择（Bit Select）
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vbslq_u8(mask, a, b)`  | 按掩码选择 `a` 或 `b`（uint8）    | `result = vbslq_u8(mask, a, b);`  |
| `vbslq_f32(mask, a, b)` | 按掩码选择 `a` 或 `b`（float32）  | `result = vbslq_f32(mask, a, b);` |

##### 其他相关函数
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vminq_f32(a, b)`       | 逐元素取最小值（隐式条件选择）    | `min_val = vminq_f32(a, b);`      |
| `vmaxq_s8(a, b)`        | 逐元素取最大值（隐式条件选择）    | `max_val = vmaxq_s8(a, b);`       |

```
// 浮点向量条件过滤
#include <arm_neon.h>

// 将负浮点数替换为 0
float32x4_t clamp_negative(float32x4_t vec) {
    // 生成掩码（vec >= 0）
    uint32x4_t mask = vcgeq_f32(vec, vdupq_n_f32(0.0f));

    // 选择原值或 0
    return vbslq_f32(mask, vec, vdupq_n_f32(0.0f));
}
```

#### 2.7 类型转换

##### 整数转浮点
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcvtq_f32_s32(a)`      | `int32x4_t` → `float32x4_t`       | `float32x4_t f = vcvtq_f32_s32(i);` |
| `vcvtq_f32_u32(a)`      | `uint32x4_t` → `float32x4_t`      | `float32x4_t f = vcvtq_f32_u32(u);` |

##### 浮点转整数
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcvtq_s32_f32(a)`      | `float32x4_t` → `int32x4_t`       | `int32x4_t i = vcvtq_s32_f32(f);` |
| `vcvtq_u32_f32(a)`      | `float32x4_t` → `uint32x4_t`      | `uint32x4_t u = vcvtq_u32_f32(f);` |

##### 窄化（Narrowing）
将高位宽向量转换为低位宽向量（可能丢失数据）。
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vqmovn_s16(a)`         | `int16x8_t` → `int8x8_t`          | `int8x8_t narrow = vqmovn_s16(a);` |
| `vqmovn_u32(a)`         | `uint32x4_t` → `uint16x4_t`       | `uint16x4_t narrow = vqmovn_u32(a);` |

##### 扩展（Widening）
将低位宽向量转换为高位宽向量（无数据丢失）。
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vmovl_s8(a)`           | `int8x8_t` → `int16x8_t`          | `int16x8_t wide = vmovl_s8(a);`   |
| `vmovl_u16(a)`          | `uint16x4_t` → `uint32x4_t`       | `uint32x4_t wide = vmovl_u16(a);` |

##### 重新解释（Reinterpret）
不改变底层数据，仅重新解释数据类型。

| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vreinterpretq_s8_u8(a)`| `uint8x16_t` → `int8x16_t`        | `int8x16_t i = vreinterpretq_s8_u8(u);` |
| `vreinterpretq_f32_u32(a)` | `uint32x4_t` → `float32x4_t`   | `float32x4_t f = vreinterpretq_f32_u32(u);` |

##### 其他相关函数
| **函数**               | **作用**                          | **示例**                          |
|-------------------------|-----------------------------------|-----------------------------------|
| `vcombine_s8(a, b)`     | 合并两个 `int8x8_t` 为 `int8x16_t` | `int8x16_t wide = vcombine_s8(a, b);` |
| `vget_low_f32(a)`       | 获取 `float32x4_t` 的低 64 位     | `float32x2_t low = vget_low_f32(a);` |

```
// 整数转浮点并归一化
#include <arm_neon.h>

// 将 int16 向量归一化到 [0, 1] 范围
float32x4_t normalize_int16(int16x4_t vec) {
    // 扩展为 int32
    int32x4_t wide = vmovl_s16(vec);

    // 转换为 float32
    float32x4_t f = vcvtq_f32_s32(wide);

    // 归一化（假设最大值为 32767）
    float32x4_t scale = vdupq_n_f32(1.0f / 32767.0f);
    return vmulq_f32(f, scale);
}
```

```
// 浮点转整数并饱和处理
#include <arm_neon.h>

// 将 float32 向量转换为 int16 并饱和处理
int16x4_t float_to_int16(float32x4_t vec) {
    // 转换为 int32
    int32x4_t i = vcvtq_s32_f32(vec);

    // 窄化为 int16（饱和处理）
    return vqmovn_s32(i);
}
```

### 3. NEON的编译和优化

参考博文[ARM平台NEON指令的编译和优化](https://blog.csdn.net/heli200482128/article/details/79303286)。


#### 3.1 NEON 核心编译选项
##### 架构与指令集指定
| **选项**                | **作用**                                  | **适用平台**       | **示例**                          |
|-------------------------|------------------------------------------|--------------------|-----------------------------------|
| `-march=armv7-a`        | 指定目标架构为 ARMv7-A（32位）           | ARMv7 (Cortex-A 系列) | `-march=armv7-a`                 |
| `-march=armv8-a+simd`   | 启用 ARMv8-A 架构和 NEON（SIMD）支持     | ARMv8 (AArch64)    | `-march=armv8-a+simd`            |
| `-mcpu=cortex-a53`      | 针对特定 CPU 优化（自动启用支持的 NEON） | 指定具体处理器型号 | `-mcpu=cortex-a72`               |

##### FPU 配置（仅 ARMv7）
| **选项**                | **作用**                                  | **示例**                          |
|-------------------------|------------------------------------------|-----------------------------------|
| `-mfpu=neon`            | 启用 NEON 浮点单元                       | `-mfpu=neon`                     |
| `-mfpu=neon-vfpv4`      | 启用 NEON 和 VFPv4                       | `-mfpu=neon-vfpv4`               |

##### 浮点 ABI 配置
| **选项**                | **作用**                                  | **示例**                          |
|-------------------------|------------------------------------------|-----------------------------------|
| `-mfloat-abi=hard`      | 使用硬件浮点调用约定（推荐）             | `-mfloat-abi=hard`               |
| `-mfloat-abi=softfp`    | 兼容软浮点 ABI，但允许硬件浮点指令       | `-mfloat-abi=softfp`             |

#### 3.2 优化与自动向量化
##### 优化级别
| **选项**                | **作用**                                  | **示例**                          |
|-------------------------|------------------------------------------|-----------------------------------|
| `-O3`                   | 最高优化级别，包含自动向量化             | `-O3`                            |
| `-Ofast`                | 激进优化（可能违反严格标准）             | `-Ofast`                         |

##### 自动向量化控制
| **选项**                | **作用**                                  | **示例**                          |
|-------------------------|------------------------------------------|-----------------------------------|
| `-ftree-vectorize`      | 启用自动向量化（默认在 `-O3` 开启）      | `-ftree-vectorize`               |
| `-funsafe-math-optimizations` | 允许激进浮点优化（可能影响精度）   | `-funsafe-math-optimizations`    |

#### 3.3 调试与诊断
| **选项**                | **作用**                                  | **示例**                          |
|-------------------------|------------------------------------------|-----------------------------------|
| `-S`                    | 生成汇编代码（检查 NEON 指令生成）       | `gcc -S -o code.s neon_code.c`   |
| `-fopt-info-vec`        | 输出自动向量化报告                       | `-fopt-info-vec`                 |

#### 3.4 完整编译命令示例

##### ARMv7 (32位) 平台
```bash
gcc -O3 -march=armv7-a -mfpu=neon -mfloat-abi=hard -o neon_exe neon_code.c
```

##### ARMv8 (64位) 平台
```bash
gcc -O3 -march=armv8-a+simd -o neon_exe neon_code.c
```
