本文主要整理PA4的要点。

## 1 上下文切换

上下文的本质是进程的状态，假设进程A运行的过程中触发了系统调用, 通过自陷指令陷入到内核。 根据__am_asm_trap()的代码, A的上下文结构(Context)将会被保存到A的栈上。 在PA3中, 系统调用处理完毕之后, __am_asm_trap()会根据栈上保存的上下文结构来恢复A的上下文。 神奇的地方来了, 如果我们先不着急恢复A的上下文, 而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢? 由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文。从__am_asm_trap()返回之后, 我们已经在运行进程B了!

![上下文切换](https://ysyx.oscc.cc/docs/assets/Context-switch.6ad11765.png)

那进程A到哪里去了呢? 别担心, 它只是被暂时"挂起"了而已。在被挂起之前, 它已经把上下文结构保存到自己的栈上了, 如果将来的某一时刻栈顶指针被切换到A的栈上, 代码将会根据栈上的上下文结构来恢复A的上下文, A将得以唤醒并执行。所以, **上下文切换其实就是不同进程之间的栈切换**!

创建**内核线程的上下文**是通过CTE提供的kcontext()函数 (在abstract-machine/am/src/$ISA/nemu/cte.c中定义)来实现的, 其中的"k"代表内核. kcontext()的原型是

```
Context* kcontext(Area kstack, void (*entry)(void *), void *arg);
```

其中kstack是栈的范围, entry是内核线程的入口, arg则是内核线程的参数。此外, kcontext()要求内核线程不能从entry返回, 否则其行为是未定义的。你需要在kstack的底部创建一个以entry为入口的上下文结构(目前你可以先忽略arg参数), 然后返回这一结构的指针。

上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文, 则是由操作系统来决定的, 这项任务叫做**进程调度**。 进程调度是由schedule()函数来完成的，然后在CTE的__am_asm_trap()中才真正地恢复这一上下文。

## 2 用户进程

和内核线程不同, 用户进程的代码, 数据和堆栈都应该位于用户区, 而且需要保证用户进程能且只能访问自己的代码, 数据和堆栈。为了区别开来, 我们把**PCB中的栈称为内核栈, 位于用户区的栈称为用户栈**。于是我们需要一个有别于kcontext()的方式来创建用户进程的上下文, 为此AM额外准备了一个API ucontext()(在abstract-machine/am/src/nemu/isa/$ISA/vme.c中定义), 它的原型是

```
Context* ucontext(AddrSpace *as, Area kstack, void *entry);
```

其中, 参数as用于限制用户进程可以访问的内存; kstack是内核栈, 用于分配上下文结构, entry则是用户进程的入口。

用户进程由操作系统创建, 很自然参数和环境变量的传递就需要由操作系统来负责。**最适合存放参数和环境变量的地方就是用户栈了**, 因为在首次切换到用户进程的时候, 用户栈上的内容就已经可以被用户进程访问。 于是操作系统在加载用户进程的时候, 还需要负责把argc/argv/envp以及相应的字符串放在用户栈中, 并把它们的存放方式和位置作为和用户进程的约定之一, 这样用户进程在_start中就可以根据约定访问它们了。这项约定其实**属于ABI**的内容, ABI手册有一节Process Initialization的内容, 里面详细约定了操作系统需要为用户进程的初始化提供哪些信息。在Project-N系统里面, 只需要一个简化版的Process Initialization: 操作系统将argc/argv/envp及其相关内容放置到用户栈上, 然后将GPRx设置为argc所在的地址。

```
|               |
+---------------+ <---- ustack.end
|  Unspecified  |
+---------------+
|               | <----------+
|    string     | <--------+ |
|     area      | <------+ | |
|               | <----+ | | |
|               | <--+ | | | |
+---------------+    | | | | |
|  Unspecified  |    | | | | |
+---------------+    | | | | |
|     NULL      |    | | | | |
+---------------+    | | | | |
|    ......     |    | | | | |
+---------------+    | | | | |
|    envp[1]    | ---+ | | | |
+---------------+      | | | |
|    envp[0]    | -----+ | | |
+---------------+        | | |
|     NULL      |        | | |
+---------------+        | | |
| argv[argc-1]  | -------+ | |
+---------------+          | |
|    ......     |          | |
+---------------+          | |
|    argv[1]    | ---------+ |
+---------------+            |
|    argv[0]    | -----------+
+---------------+
|      argc     |
+---------------+ <---- cp->GPRx
|               |
```

## 3 SYS_execve

当Nanos-lite尝试通过SYS_execve加载B时, 可以从栈底(heap.end)到栈顶(栈指针sp当前的位置)列出A用户栈中的内容:

- Nanos-lite之前为A传递的用户进程参数(argc/argv/envp)
- A从_start开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的execve()
- CTE保存的上下文结构, 这是由于A在execve()中执行了系统调用自陷指令导致的
- Nanos-lite从__am_irq_handle()开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了SYS_execve的系统调用处理函数

因此heap.end附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈, 来让Nanos-lite把B的参数放置到这个新分配的用户栈里面。最后, 为了结束A的执行流, 可以在创建B的上下文之后, 通过switch_boot_pcb()修改当前的current指针, 然后调用yield()来强制触发进程调度. 这样以后, A的执行流就不会再被调度, 等到下一次调度的时候, 就可以恢复并执行B了。

## 4 将虚存管理抽象成VME

虚存机制, 说白了就是个映射(或函数)。也就是说, 本质上虚存管理要做的事情, 就是在维护这个映射。但这个映射应该是每个进程都各自维护一份, 因此我们需要如下的两个API:

```
// 创建一个默认的地址空间
void protect(AddrSpace *as);

// 销毁指定的地址空间
void unprotect(AddrSpace *as);
```

其中AddrSpace是一个结构体类型, 定义了地址空间描述符的结构(在abstract-machine/am/include/am.h中定义):

```
typedef struct AddrSpace {
  int pgsize;
  Area area;
  void *ptr;
} AddrSpace;
```

其中pgsize用于指示页面的大小, area表示虚拟地址空间中用户态的范围, ptr是一个ISA相关的地址空间描述符指针, 用于指示具体的映射。有了地址空间, 我们还需要有相应的API来维护它们. 于是很自然就有了如下的API:

```
void map(AddrSpace *as, void *va, void *pa, int prot);
```

它用于将地址空间as中虚拟地址va所在的虚拟页, 以prot的权限映射到pa所在的物理页。 当prot中的present位为0时, 表示让va的映射无效。

## 5 内核栈和用户栈切换

**操作系统不能相信陷入内核时栈指针的值**, 在进行任何栈操作之前(包括保存上下文), 操作系统都需要先把栈指针指向一个自己准备的栈, 这个过程称为"栈切换"(stack switching)。在这之后, 保存上下文的位置就在操作系统的掌控之下, 从而解决了上述恶意程序的问题。这个操作系统自己准备的栈, 就是我们之前介绍的**内核栈**。为了实现栈切换, 我们需要实现如下功能:
- 如果是从用户态进入CTE, 则在CTE保存上下文之前, 先切换到内核栈, 然后再保存上下文
- 如果将来返回到用户态, 则在CTE从内核栈恢复上下文之后, 则先切换到用户栈, 然后再返回

为了实现上述功能, 我们又需要解决如下问题:

- 如何识别进入CTE之前处于用户态还是内核态? - pp (Previous Privilege)
- CTE的代码如何知道内核栈在什么位置? - ksp (Kernel Stack Pointer)
- 如何知道将要返回的是用户态还是内核态? - np (Next Privilege)
- CTE的代码如何知道用户栈在什么位置? - usp (User Stack Pointer)

```
void __am_asm_trap() {
  if (pp == USER) {
    usp = $sp;
    $sp = ksp;
  }
  np = pp;

  // save context

  __am_irq_handle(c);

  // restore context

  pp = np;
  if (np == USER) {
    ksp = $sp;
    $sp = usp;
  }

  return_from_trap();
}
```