
## 10 - 系统编程与基础设施

### 10.1 基础设施

- 通过适当的配置、脚本减少思维中断的时间，提高连贯性，保持短时记忆活跃
- 基本原则：如果你认为有提高效率的可能性，一定有人已经做了
- 一个神奇的编译选项，-fsanitize=address，Address Sanitizer; asan “动态程序分析”

### 10.2 Differential Testing

**1. qemu-diff 实现**

- 启用gdb连接QEMU  
- 用gdb_si() 在QEMU 中执行一条指令  
- 比较指令执行后寄存器是否有区别  
- 启动QEMU并配置它进入与PA 类似的模式  

```
// nemu/tools/qemu-diff/src/diff-test.c
__EXPORT void difftest_init(int port) {
  char buf[32];
  sprintf(buf, "tcp::%d", port);

  int ppid_before_fork = getpid();
  int pid = fork();
  if (pid == -1) {
    perror("fork");
    assert(0);
  }
  // 子进程
  else if (pid == 0) {
    // child

    // install a parent death signal in the chlid
    int r = prctl(PR_SET_PDEATHSIG, SIGTERM);
    if (r == -1) {
      perror("prctl error");
      assert(0);
    }

    if (getppid() != ppid_before_fork) {
      printf("parent has died!\n");
      assert(0);
    }

    close(STDIN_FILENO);
    execlp(ISA_QEMU_BIN, ISA_QEMU_BIN, ISA_QEMU_ARGS "-S", "-gdb", buf, "-nographic",
        "-serial", "none", "-monitor", "none", NULL);
    perror("exec");
    assert(0);
  }
  // 父进程
  else {
    // father

    // 连接qemu
    gdb_connect_qemu(port);
    printf("Connect to QEMU with %s successfully\n", buf);

    atexit(gdb_exit);

    init_isa();
  }
}
```

```
// 通信获取regs
bool gdb_getregs(union isa_gdb_regs *r) {
  gdb_send(conn, (const uint8_t *)"g", 1);
  size_t size;
  uint8_t *reply = gdb_recv(conn, &size);

  int i;
  uint8_t *p = reply;
  uint8_t c;
  for (i = 0; i < sizeof(union isa_gdb_regs) / sizeof(uint32_t); i ++) {
    c = p[8];
    p[8] = '\0';
    r->array[i] = gdb_decode_hex_str(p);
    p[8] = c;
    p += 8;
  }

  free(reply);

  return true;
}

// 单步执行
bool gdb_si() {
  char buf[] = "vCont;s:1";
  gdb_send(conn, (const uint8_t *)buf, strlen(buf));
  size_t size;
  uint8_t *reply = gdb_recv(conn, &size);
  free(reply);
  return true;
}

```

**2. qemu初始化**

```c
static uint8_t mbr[] = {
  // 16位实模式代码
  0xfa,                           // cli
  0x31, 0xc0,                     // xorw   %ax,%ax
  0x8e, 0xd8,                     // movw   %ax,%ds
  0x8e, 0xc0,                     // movw   %ax,%es
  0x8e, 0xd0,                     // movw   %ax,%ss
  0x0f, 0x01, 0x16, 0x44, 0x7c,   // lgdt   gdtdesc
  0x0f, 0x20, 0xc0,               // movl   %cr0,%eax
  0x66, 0x83, 0xc8, 0x01,         // orl    $CR0_PE,%eax
  0x0f, 0x22, 0xc0,               // movl   %eax,%cr0
  0xea, 0x1d, 0x7c, 0x08, 0x00,   // ljmp   $0x0008,$0x7c1d

  // 32位保护模式代码
  0x66, 0xb8, 0x10, 0x00,         // movw   $0x10,%ax
  0x8e, 0xd8,                     // movw   %ax, %ds
  0x8e, 0xc0,                     // movw   %ax, %es
  0x8e, 0xd0,                     // movw   %ax, %ss
  0xeb, 0xfe,                     // jmp    $0x7c27 (无限循环)
  0x8d, 0x76, 0x00,               // lea    0x0(%esi),%esi (空指令填充)

  // 全局描述符表 (GDT)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 空描述符
  0xff, 0xff, 0x00, 0x00, 0x00, 0x9a, 0xcf, 0x00, // 代码段描述符
  0xff, 0xff, 0x00, 0x00, 0x00, 0x92, 0xcf, 0x00, // 数据段描述符

  // GDT描述符 (gdtdesc)
  0x17, 0x00, 0x2c, 0x7c, 0x00, 0x00             // 大小0x17, 地址0x7c2c
};
```

**总结**
该 MBR 代码实现了以下功能：
1.**初始化实模式环境**：关闭中断，清零段寄存器。
2.**准备保护模式**：加载 GDT，设置 `CR0.PE` 位。
3.**切换到保护模式**：通过长跳转激活代码段选择子。
4.**初始化保护模式环境**：设置数据段寄存器。
5.**进入无限循环**：实际引导程序应在此后加载操作系统内核。
此代码是一个简化的保护模式切换示例，实际 MBR 需进一步添加磁盘读取和内核加载逻辑。

## 12 - 中断与分时多任务

### 12.1 进程与控制流

进程的地址空间是操作系统为每个运行中的进程分配的虚拟内存布局，确保进程间隔离且安全地访问内存。

**1. 进程地址空间的核心组成**

**代码段（Text Segment）**
- **位置**：通常位于虚拟地址空间的低地址区域。
- **内容**：存放可执行指令（编译后的机器码）。
- **权限**：**只读（R-X）**，防止程序意外修改自身代码。
- **特点**：
  - 多个进程可共享同一代码段（如动态库）。
  - 通过内存映射文件实现（如可执行文件本身）。

**数据段（Data Segment）**
- **已初始化数据段（.data）**：
  - 存放显式初始化的全局变量和静态变量。
  - **权限**：可读写（RW-），不可执行。
- **未初始化数据段（.bss）**：
  - 存放未初始化的全局变量和静态变量。
  - **权限**：可读写（RW-），程序加载时由系统初始化为零。

**堆（Heap）**
- **位置**：紧接数据段，向高地址动态增长。
- **功能**：用于程序运行时动态分配内存（如 `malloc`、`new`）。
- **管理**：由内存分配器（如 `glibc` 的 `ptmalloc`）管理空闲块。
- **权限**：可读写（RW-），不可执行。

**栈（Stack）**
- **位置**：通常位于虚拟地址空间的高地址区域，向低地址增长。
- **功能**：
  - 存储函数调用的返回地址、参数和局部变量。
  - 支持函数嵌套调用和递归。
- **管理**：由编译器自动分配和释放（如 `push`/`pop` 指令）。
- **权限**：可读写（RW-），现代系统通常禁止执行（NX 位）。

**内存映射区域（Memory-Mapped Region）**
- **位置**：位于堆和栈之间的动态区域。
- **内容**：
  - **共享库**：如 `libc.so`、`libm.so`，多个进程共享同一物理内存。
  - **文件映射**：通过 `mmap` 将文件直接映射到内存（如加载大型文件）。
  - **匿名映射**：用于进程间共享内存（如 `shm_open`）。
- **权限**：根据用途设置（如可读、可写、可执行）。

**内核空间（Kernel Space）**
- **位置**：虚拟地址空间的高端（如 32 位 Linux 中 `0xC0000000` 以上）。
- **权限**：仅内核态可访问，用户进程无法直接操作。
- **内容**：内核代码、数据结构、设备内存映射等。

**2. 典型布局示例（Linux x86-64）**
```
高地址
+------------------------------------+ 0x7ffffffff000
|              栈（Stack）            | ↘ 向低地址增长
+------------------------------------+
|               ...                  | （随机偏移，ASLR）
+------------------------------------+
|           内存映射区域               | （共享库、文件映射等）
+------------------------------------+
|              堆（Heap）             | ↗ 向高地址增长
+------------------------------------+
|              .bss 段               |
+------------------------------------+
|              .data 段              |
+------------------------------------+
|              .text 段              | 代码段（程序指令）
+------------------------------------+ 0x400000
低地址
```

**3. 关键技术与特性**

**虚拟内存与页表**
- **虚拟地址**：进程视角的连续地址空间。
- **物理地址**：实际内存硬件地址，由操作系统通过页表动态映射。
- **页表**：多级结构（如 x86-64 的四级页表），实现虚拟到物理地址的转换。

**地址空间随机化（ASLR）**
- **作用**：随机化堆、栈、共享库的基地址，增强安全性。
- **实现**：通过内核配置 `/proc/sys/kernel/randomize_va_space` 控制。

**内存保护**
- **权限位**：页表项中的读（R）、写（W）、执行（X）位，防止非法访问。
- **不可执行（NX）**：现代 CPU 支持，阻止栈和堆中的代码执行。

**写时复制（Copy-on-Write, COW）**
- **应用**：`fork()` 创建子进程时，共享父进程内存，仅在修改时复制。
- **优点**：减少内存开销，加速进程创建。

**4. 查看进程地址空间**
**Linux 工具**
- **`pmap`**：查看进程的内存映射。
  ```bash
  pmap -X <PID>
  ```
- **`/proc/<PID>/maps`**：文本形式显示内存区域。
  ```bash
  cat /proc/self/maps  # 查看当前进程的地址空间
  ```
- **`readelf`**：分析可执行文件的内存布局。
  ```bash
  readelf -l <executable>
  ```
进程的地址空间通过虚拟内存技术，实现了以下核心功能：
- **隔离性**：每个进程拥有独立的虚拟地址空间，互不干扰。
- **灵活性**：动态分配堆和内存映射区域，适应程序需求。
- **安全性**：权限控制和 ASLR 防止恶意攻击。
- **高效性**：共享库和 COW 技术优化资源使用。

**5.程序执行只有正常控制流么？**
- 来自内部的异常，缺页，越权，溢出等
- 其他原因打断正常执行，外部中断（打印机异常等），进程切换
- 产生异常控制流，pc跳转到哪里？如何打断？跳到中断处理程序（where，how）

### 12.2 中断机制

**x86-64中断过程**  

- 自动保存RIP, CS, RFLAGS, RSP, SS, (Error Code)
- 根据中断/异常号查找跳转到处理程序
  - (特权级切换会触发堆栈切换)
  - int $0x80 指令可以产生128 号异常
  - 时钟会产生32 号中断
  - 键盘会产生33 号中断
  - ……
- 中断+ 更大的内存 = 分时多线程
- 分时多线程+ 虚拟存储 = 进程

**为什么死循环不会把电脑卡死？**  

- 中断是强制的(普通的进程不能关闭)
  - Ring 3 关闭中断将导致Exception
  - 系统调用（陷阱）是特殊异常事件，是OS为用户程序提供服务，如： int $0x80
- 中断发生后，操作系统代码将会切换到另一个进程执行


### 12.3. x86中断处理流程
**(1) 保存上下文**
- **自动保存**：处理器自动将以下寄存器压入内核栈：
  - **EFLAGS**：状态寄存器。
  - **CS:EIP**：当前代码段和指令指针。
  - **Error Code（可选）**：部分异常（如`#PF`）会压入错误码。
- **特权级变化时**：若中断导致特权级切换（如用户态→内核态），额外压入：
  - **SS:ESP**：用户态栈指针。

**(2) 加载中断处理程序**
1. **根据中断号查找IDT条目**：中断向量号 × 8（每个条目8字节）得到IDT偏移。
2. **检查权限**：若当前特权级（CPL） ≤ 门描述符的DPL，允许执行。
3. **跳转到处理程序**：从门描述符中加载目标代码段选择子和偏移地址，更新`CS:EIP`。

**(3) 执行中断处理程序**
- **保存通用寄存器**：手动保存`eax`、`ebx`等寄存器（通过`pusha`或手动压栈）。
- **处理中断源**：
  - **硬件中断**：读取设备状态，处理请求（如读取键盘缓冲区）。
  - **异常**：修复错误（如分配页面）或终止进程。
- **发送EOI（End of Interrupt）**：
  - **PIC模式**：向主/从PIC发送`0x20`到`0x20`和`0xA0`端口。
  - **APIC模式**：写入APIC的EOI寄存器。

**(4) 恢复上下文并返回**
- **恢复通用寄存器**：通过`popa`或手动出栈。
- **执行`iret`指令**：从栈中依次弹出`EIP`、`CS`、`EFLAGS`（若发生特权级切换，还需弹出`SS:ESP`）。
- **继续执行原程序**：处理器恢复到中断前的执行流。

### 12.4. riscv32中断处理流程

**(1) 中断处理核心寄存器**
| **寄存器**      | **作用**                                                                 |
|-----------------|-------------------------------------------------------------------------|
| `mstatus`       | 全局状态寄存器，包含中断使能位 `MIE`、特权模式信息等。                   |
| `mie`           | 中断使能寄存器，控制三类中断的全局使能。                                 |
| `mip`           | 中断等待寄存器，记录当前挂起的中断类型。                                 |
| `mtvec`         | 中断向量基地址，指定中断处理程序的入口。                                 |
| `mcause`        | 记录中断/异常的原因码（如外部中断=11，定时器中断=7）。                   |
| `mepc`          | 保存中断发生时的 `pc` 值，用于 `mret` 返回。                             |
| `mscratch`      | 临时寄存器，通常用于保存上下文切换时的栈指针。                           |

**(2) 硬件自动处理**
当满足中断条件（`mie & mip ≠ 0` 且 `mstatus.MIE = 1`）时，硬件依次执行：
1. **关闭全局中断**：`mstatus.MIE` 位清零，防止嵌套中断。
2. **保存当前 `pc`**：将中断发生时的指令地址存入 `mepc`。
3. **保存特权模式**：将当前模式（如 U-mode 或 S-mode）记录到 `mstatus.MPP`。
4. **切换至 M-mode**：无论当前处于何模式，强制进入机器模式（最高特权级）。
5. **跳转至中断处理程序**：根据 `mtvec` 寄存器中的基地址：
   - **直接模式（`mtvec[0]=0`）**：所有中断跳转到 `mtvec.base`。
   - **向量模式（`mtvec[0]=1`）**：跳转到 `mtvec.base + 4 * cause`。

**(3) 软件处理程序**
在 `mtvec` 指向的中断处理程序中：
1. **保存上下文**：
   - 手动保存通用寄存器（`x1-x31`）到栈或预留内存。
   - 保存 `mepc`、`mcause` 等关键 CSR。
   ```asm
   csrrw sp, mscratch, sp  // 使用 mscratch 切换栈指针
   sw x1, 0(sp)            // 保存 x1
   // ... 保存其他寄存器
   ```
2. **解析中断原因**：
   ```asm
   csrr a0, mcause         // 将 mcause 值存入 a0
   srli a1, a0, 31         // 检查是否为中断（a1=1）或异常（a1=0）
   andi a0, a0, 0xFF       // 获取原因码（mcause 低 8 位）
   ```
3. **处理中断**：
   - **外部中断**：查询 PLIC 的 `claim` 寄存器，获取中断源并处理。
   - **定时器中断**：更新 `mtimecmp`，重置定时器。
   - **软件中断**：清除 `msip` 并处理核间通信。
4. **清除中断挂起标志**：
   ```asm
   csrrc zero, mip, <mask> // 清除 mip 对应位
   ```

**(4) 恢复上下文并返回**
1. **恢复寄存器**：
   ```asm
   lw x1, 0(sp)            // 恢复 x1
   // ... 恢复其他寄存器
   csrrw sp, mscratch, sp  // 恢复原栈指针
   ```
2. **恢复特权模式与中断使能**：
   ```asm
   csrw mepc, mepc         // 确保 mepc 未改变（可选）
   mret                    // 恢复 mstatus.MIE，跳转至 mepc
   ```

## 14 - 虚拟存储选讲

虚拟内存地址到物理内存地址的转换是通过分页机制实现的，其核心步骤包括地址分解、页表查询和权限验证。

### **1. 地址分解**
虚拟地址通常分为两部分：
- **页号（Virtual Page Number, VPN）**：用于在页表中查找对应的物理页框。
- **页内偏移（Page Offset）**：直接映射到物理地址的页内位置。

**示例**（32位系统，4KB页大小）：
- 虚拟地址：32位
- 页内偏移：12位（\(2^{12} = 4KB\)）
- 页号：20位（剩余高位，\(32-12=20\)）

虚拟地址格式：
```
| 20位页号 (VPN) | 12位页内偏移 |
```

### **2. 页表结构**
页表是一个多级数据结构，逐级缩小搜索范围以节省内存。以 **x86 两级页表（32位）** 为例：
1. **页目录（Page Directory）**：
   - 每个进程有一个页目录，由 **CR3 寄存器** 指向其物理地址。
   - 页目录项（Page Directory Entry, PDE）指向下级页表。
2. **页表（Page Table）**：
   - 页表项（Page Table Entry, PTE）包含物理页框号和权限标志。

**虚拟地址分解**：
```
| 10位页目录索引 | 10位页表索引 | 12位页内偏移 |
```

### **3. 地址翻译流程**
以虚拟地址 `0x12345678` 转换为物理地址为例：

**(1) 分解虚拟地址**
- **页目录索引**：高10位 → `0x12345678 >> 22 = 0x48`（十进制72）。
- **页表索引**：中间10位 → `(0x12345678 >> 12) & 0x3FF = 0x345`（十进制837）。
- **页内偏移**：低12位 → `0x678`（十进制1656）。

**(2) 查找页目录项**
- 从 **CR3 寄存器** 获取页目录的物理基地址。
- 计算页目录项地址：`CR3 + 页目录索引 * 4`（每项4字节）。
- 读取 PDE，获取页表的物理基地址。

**(3) 查找页表项**
- 根据 PDE 中的页表基地址，计算页表项地址：`页表基地址 + 页表索引 * 4`。
- 读取 PTE，获取物理页框号（Physical Frame Number, PFN）。

**(4) 组合物理地址**
- 物理地址 = `(PFN << 12) | 页内偏移`。

**示例计算**：
- 假设 PTE 中的 PFN 为 `0x8000`：
  ```
  物理地址 = (0x8000 << 12) + 0x678 = 0x8000000 + 0x678 = 0x8000678
  ```

### **4. 关键硬件支持**
**(1) TLB（Translation Lookaside Buffer）**
- **作用**：缓存最近使用的虚拟页到物理页的映射，加速翻译。
- **工作流程**：
  1. CPU 访问虚拟地址时，先查询 TLB。
  2. 命中（TLB Hit）：直接获取物理页框号。
  3. 未命中（TLB Miss）：触发页表遍历，更新 TLB。

**(2) MMU（Memory Management Unit）**
- **功能**：自动执行地址翻译和权限检查。
- **权限验证**：
  - 检查 PTE 中的权限位（如可读、可写、可执行）。
  - 若访问违规（如写入只读页），触发 **段错误（Segmentation Fault）**。

### **5. 多级页表示例（x86-64 四级页表）**
64位系统使用更多层级以适应更大的地址空间：
```
| 9位 PML4 索引 | 9位 PDP 索引 | 9位 PD 索引 | 9位 PT 索引 | 12位页内偏移 |
```
- **PML4（Page Map Level 4）**：顶级页表，由 CR3 寄存器指向。
- **PDP（Page Directory Pointer）**、**PD（Page Directory）**、**PT（Page Table）**：逐级索引。
- 最终物理地址计算方式与32位类似，但需遍历四级页表。

### **6. 缺页处理**
若页表项标记为 **不存在（Present Bit = 0）**，触发缺页异常：
1. 操作系统分配物理页框，可能从磁盘加载数据（Swap In）。
2. 更新页表项，设置 Present Bit 和物理页框号。
3. 重新执行引发异常的指令。

### **7. 总结**
| **步骤**               | **操作**                                                                 |
|------------------------|-------------------------------------------------------------------------|
| 1. 地址分解             | 拆分虚拟地址为页号和页内偏移。                                          |
| 2. 页表查询             | 逐级查找页目录和页表，获取物理页框号。                                  |
| 3. 物理地址生成         | 组合物理页框号和页内偏移。                                              |
| 4. TLB 缓存             | 加速后续相同虚拟地址的翻译。                                            |
| 5. 权限检查             | 验证访问权限，违规时触发异常。                                          |
| 6. 缺页处理（可选）     | 若页未加载，由操作系统处理并更新页表。                                  |

通过这一机制，操作系统实现了内存隔离、按需分页和高效地址转换，支撑了现代多任务系统的运行。

