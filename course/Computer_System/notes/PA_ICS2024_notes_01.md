
## 1 - The Missing Course of Your CS Education

### 1.1 NEMU，一个简化的全系统模拟器

| 实验细节         | 难度      | 内容         | 目标 | 
|-----------------|-----------|------------- |------|
| PA0-环境预备            | ★☆☆☆☆   | 准备linux开发环境及NEMU | 框架运⾏所需⼯具链 |  
| PA1-简易调试器           | ★★★☆☆   | 实现表达式求值及监视器功能，为NEMU上debug做准备  | 安装并正确运⾏NEMU框架     |
| PA2-冯诺依曼计算机系统   | ★★★★☆    | 实现riscv32核⼼指令集翻译，实现基本库函数并封装klib  | 能够成功计算表达式并实现断点管理 |
| PA3-批处理系统          | ★★★★★    | 实现批处理系统，支持自动加载程序，支持异常处理及上下⽂切换恢复    | 运⾏纯计算程序，类hello world程序，及字符版本超级玛丽 |     
| PA4-分时多任务（鼓励）   | ★★★★★    | 分时多任务功能  | 运⾏Flappy Bird和PAL仙剑奇侠传  |    

### 1.2 UNIX哲学
- **Keep it simple, stupid. (KISS)**
   - Everything is a file and pipeline programs to work together
- 一个命令只做“一件事”
   - 从stdin输入（prinf）
   - 向stdout输出（scanf）
   - 使用参数控制行为（int main (int argc, char * argv[]);）
- 命令的输入和输出都是人类 + 机器均可读的文本
   - find .
   - wc -l a.txt b.txt
- 把命令的输入/输出连接起来(管道) 协作完成任务
   - find . | grep '\.cpp$' | xargs cat | wc -l

## 2 - The Missing Course of Your CS Education

### 2.1 正则表达式

#### **核心元字符**
| **元字符** | **作用**                        | **示例**                     |
|------------|---------------------------------|------------------------------|
| `.`        | 匹配任意单个字符（换行符除外）     | `a.c` → `abc`、`a1c`         |
| `^`        | 匹配行首                        | `^start` → 以 "start" 开头的行 |
| `$`        | 匹配行尾                        | `end$` → 以 "end" 结尾的行     |
| `*`        | 前导字符出现 **0次或多次**        | `ab*c` → `ac`、`abc`、`abbc`  |
| `+`        | 前导字符出现 **1次或多次**        | `ab+c` → `abc`、`abbc`        |
| `?`        | 前导字符出现 **0次或1次**         | `ab?c` → `ac`、`abc`          |
| `{n,m}`    | 前导字符出现 **n到m次**           | `a{2,4}` → `aa`、`aaa`、`aaaa`|
| `[...]`    | 匹配括号内任意字符                | `[aeiou]` → 匹配任意元音字母    |
| `[^...]`   | 匹配不在括号内的字符              | `[^0-9]` → 非数字字符           |
| `|`        | 逻辑或（ERE/PCRE）               | `cat|dog` → 匹配 "cat" 或 "dog" |
| `()`       | 分组捕获                        | `(ab)+` → `ab`、`abab`         |
| `\`        | 转义字符                        | `\.` → 匹配实际点号             |

#### **预定义字符类**
| **简写** | **等价表达式**    | **说明**               |
|----------|------------------|-----------------------|
| `\d`     | `[0-9]`          | 数字                  |
| `\D`     | `[^0-9]`         | 非数字                |
| `\s`     | `[ \t\r\n\f]`    | 空白字符              |
| `\S`     | `[^ \t\r\n\f]`   | 非空白字符            |
| `\w`     | `[a-zA-Z0-9_]`   | 单词字符（字母数字下划线） |
| `\W`     | `[^a-zA-Z0-9_]`  | 非单词字符            |

#### **常用工具与示例**
##### **1. `grep` 文本搜索**
```bash
# 基本正则 (BRE)
grep '^error' log.txt          # 查找以 "error" 开头的行
grep 'end$' log.txt           # 查找以 "end" 结尾的行
grep 'a\{2,4\}' file          # 查找连续出现2-4次的 "a"

# 扩展正则 (ERE)
grep -E 'go+d' file           # 匹配 "god"、"good"、"gooood"
grep -E '(error|warn)' file   # 匹配含 "error" 或 "warn" 的行
```

##### **2. `sed` 文本替换**
```bash
# 基本正则 (BRE)
sed 's/old/new/' file         # 替换每行第一个 "old" 为 "new"
sed 's/[0-9]\+//g' file       # 删除所有数字（\+需转义）

# 扩展正则 (ERE)
sed -r 's/(ab)+/X/g' file     # 替换连续 "ab" 为 "X"
```

##### **3. `awk` 模式处理**
```bash
# 默认支持 ERE
awk '/^[A-Z]/ {print}' file   # 打印以大写字母开头的行
awk '$3 ~ /^[0-9]{4}$/' file  # 第三列为4位数字时输出
```

#### **常见场景示例**
##### **1. 匹配 IP 地址**
```bash
grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' access.log
```
##### **2. 提取邮箱地址**
```bash
grep -Eo '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}' emails.txt
```
##### **3. 删除空行**
```bash
sed '/^$/d' file
```
##### **4. 匹配日期 (YYYY-MM-DD)**
```bash
grep -E '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$' dates.txt
```

### 2.2 从源代码到可执行文件

C语言从源代码到可执行文件的整个过程可以分为以下四个主要阶段，每个阶段都有其特定的任务和工具：

#### **1. 预处理（Preprocessing）**
- **任务**：  
  处理源代码中的预处理指令（以 `#` 开头的指令），生成纯C代码。
- **主要操作**：  
  - 展开宏定义（`#define`）。  
  - 包含头文件（`#include`）。  
  - 条件编译（`#if`、`#ifdef` 等）。  
  - 删除注释。  
- **工具**：  
  `cpp`（C Preprocessor）。  
- **输出文件**：  
  生成 `.i` 文件（预处理后的源代码）。  
- **示例命令**：  
  ```bash
  gcc -E main.c -o main.i
  ```

#### **2. 编译（Compilation）**
- **任务**：  
  将预处理后的C代码翻译为汇编代码。  
- **主要操作**：  
  - 词法分析：将源代码分解为词法单元（Token）。  
  - 语法分析：生成抽象语法树（AST）。  
  - 语义分析：检查类型、变量声明等语义规则。  
  - 代码优化：生成中间代码并进行优化。  
  - 生成汇编代码：将中间代码转换为目标机器的汇编代码。  
- **工具**：  
  `cc1`（GCC的编译器前端）。  
- **输出文件**：  
  生成 `.s` 文件（汇编代码）。  
- **示例命令**：  
  ```bash
  gcc -S main.i -o main.s
  ```

#### **3. 汇编（Assembly）**
- **任务**：  
  将汇编代码翻译为机器码（目标文件）。  
- **主要操作**：  
  - 将汇编指令逐条翻译为机器指令。  
  - 生成符号表（Symbol Table）和重定位信息。  
- **工具**：  
  `as`（汇编器）。  
- **输出文件**：  
  生成 `.o` 文件（目标文件）。  
- **示例命令**：  
  ```bash
  gcc -c main.s -o main.o
  ```

#### **4. 链接（Linking）**
- **任务**：  
  将多个目标文件和库文件合并，生成最终的可执行文件。  
- **主要操作**：  
  - 符号解析：将未定义的符号与定义关联。  
  - 重定位：调整代码和数据的地址。  
  - 合并段：将目标文件的段（如 `.text`、`.data`）合并。  
  - 解决依赖：链接静态库（`.a`）或动态库（`.so`）。  
- **工具**：  
  `ld`（链接器）。  
- **输出文件**：  
  生成可执行文件（如 `a.out` 或指定名称）。  
- **示例命令**：  
  ```bash
  gcc main.o -o main
  ```

#### **5. 完整流程示例**
```bash
# 预处理
gcc -E main.c -o main.i

# 编译
gcc -S main.i -o main.s

# 汇编
gcc -c main.s -o main.o

# 链接
gcc main.o -o main
```

#### **6. 总结**
| **阶段**     | **输入**      | **输出**      | **工具**  |  
|--------------|---------------|---------------|-----------|  
| 预处理       | `.c` 文件     | `.i` 文件     | `cpp`     |  
| 编译         | `.i` 文件     | `.s` 文件     | `cc1`     |  
| 汇编         | `.s` 文件     | `.o` 文件     | `as`      |  
| 链接         | `.o` 文件 + 库 | 可执行文件    | `ld`      |  

通过以上四个阶段，C语言源代码最终被转换为可在目标机器上运行的可执行文件。

### 2.3 可执行文件执行过程

可执行文件从被用户启动到最终在计算机上运行的整个流程可以分为以下几个关键步骤，以Linux系统为例：

#### **1. 用户触发执行**
- **操作**：用户在终端输入命令（如 `./app`）或通过图形界面双击可执行文件。
- **系统响应**：Shell或桌面环境将执行请求传递给操作系统内核。

#### **2. 文件加载与权限验证**
- **查找文件**：操作系统根据路径找到可执行文件（如 `/home/user/app`）。
- **权限检查**：验证用户是否有执行权限（`x` 权限位）。
  - 若无权限，返回错误（`Permission denied`）。

#### **3. 创建新进程**
- **调用 `fork()`**：复制当前进程（父进程）生成子进程。
- **调用 `execve()`**：在子进程中加载并执行目标可执行文件。

#### **4. 解析可执行文件格式**
- **识别格式**：根据文件头部识别格式（如ELF、PE、Mach-O）。
  - **ELF（Linux）**：检查魔数（`0x7F ELF`）。
- **读取元数据**：解析程序头表（Program Headers）、节头表（Section Headers）等。

#### **5. 内存映射与加载**
- **分配虚拟地址空间**：为进程分配虚拟内存区域（Code、Data、Heap、Stack）。
- **加载代码段（.text）和数据段（.data）**：
  - 将代码段映射到内存（只读、可执行）。
  - 将初始化数据段映射到内存（可读写）。
- **初始化堆栈（Stack）**：
  - 设置栈指针（SP），传递命令行参数和环境变量。

#### **6. 动态链接（若需要）**
- **加载动态链接器（如 `/lib/ld-linux.so`）**：处理共享库依赖。
- **解析符号**：
  - 加载依赖的共享库（如 `libc.so`）。
  - 重定位符号地址（延迟绑定：PLT/GOT机制）。

#### **7. 设置执行上下文**
- **初始化寄存器**：将程序计数器（PC）设为入口点（如 `_start`）。
- **传递参数**：将 `argc`、`argv`、`envp` 存入栈中。

#### **8. 开始执行程序**
- **跳转到入口点**：CPU从 `_start`（由C运行时库 `crt0.o` 提供）开始执行。
- **调用 `main()`**：经过C运行时初始化后，执行用户编写的 `main` 函数。

#### **9. 程序运行与资源管理**
- **内存管理**：动态分配堆内存（`malloc`/`free`）。
- **系统调用**：程序通过 `syscall` 指令请求操作系统服务（如文件I/O、网络通信）。
- **信号处理**：响应中断信号（如 `SIGINT` 处理 Ctrl+C）。

#### **10. 程序终止**
- **正常退出**：`main` 函数返回或调用 `exit()`。
- **清理资源**：释放内存、关闭打开的文件描述符。
- **进程终止**：内核回收进程资源，父进程通过 `wait()` 获取退出状态。


#### **流程图解**
```plaintext
用户命令 → 权限检查 → 创建进程 → 解析ELF → 内存映射 → 动态链接 → 设置上下文 → 执行main() → 运行 → 终止
```

#### **关键工具与技术**
- **`strace`**：跟踪系统调用，观察程序执行流程。
- **`ldd`**：查看可执行文件依赖的共享库。
- **`readelf`**：解析ELF文件结构。
- **虚拟内存**：通过MMU实现物理与虚拟地址映射。
- **ASLR**：地址空间布局随机化（安全机制）。

#### **示例：跟踪程序启动**
```bash
# 查看动态链接过程
LD_DEBUG=libs ./app

# 跟踪系统调用
strace ./app
```

通过以上步骤，可执行文件从静态的二进制数据转变为动态运行的进程，操作系统与硬件协同完成了资源分配、代码执行和状态管理。

## 3 - C语言拾遗：机制和实践

### 3.1 可执行文件反汇编

使用 GCC 生成的可执行文件反汇编后，其汇编代码默认遵循 **AT&T 汇编语法规范**。这与常见的 Intel 语法在格式和操作数顺序上有显著区别。以下是关键差异和详细说明：

#### **1. AT&T 与 Intel 语法的主要区别**

| **特性**       | **AT&T 语法**              | **Intel 语法**            |
|-----------------|----------------------------|---------------------------|
| **操作数顺序**  | `源操作数在前，目标在后`    | `目标在前，源在后`         |
| 示例            | `movl %eax, %ebx`          | `mov ebx, eax`            |
| **寄存器前缀**  | `%` 前缀（如 `%eax`）       | 无前缀（如 `eax`）         |
| **立即数前缀**  | `$` 前缀（如 `$0x10`）      | 无前缀（如 `10h`）         |
| **内存引用**    | `disp(base, index, scale)` | `[base + index*scale + disp]` |
| 示例            | `movl 4(%ebp), %eax`       | `mov eax, [ebp + 4]`      |
| **指令后缀**    | 指定操作数大小（如 `b/w/l`）| 无后缀，通过寄存器名称隐含 |
| 示例            | `movw $0x1234, %ax`        | `mov ax, 1234h`           |

| **寄存器** | **32位名称** | **64位扩展名称** | **主要用途**                  | **AT&T语法示例** | **Intel语法示例** |
|------------|---------------|-------------------|-------------------------------|------------------|-------------------|
| **累加器** | `eax`         | `rax`             | 算术运算、函数返回值           | `%eax`          | `eax`            |
| **基址寄存器** | `ebx`      | `rbx`             | 数据指针（DS段）               | `%ebx`          | `ebx`            |
| **计数器** | `ecx`         | `rcx`             | 循环计数器、字符串操作         | `%ecx`          | `ecx`            |
| **数据寄存器** | `edx`      | `rdx`             | I/O 操作、乘除法辅助           | `%edx`          | `edx`            |
| **栈指针** | `esp`         | `rsp`             | 栈顶指针                       | `%esp`          | `esp`            |
| **基址指针** | `ebp`        | `rbp`             | 栈帧基址指针                   | `%ebp`          | `ebp`            |
| **源索引** | `esi`         | `rsi`             | 字符串/内存操作源指针          | `%esi`          | `esi`            |
| **目的索引** | `edi`        | `rdi`             | 字符串/内存操作目的指针         | `%edi`          | `edi`            |

| **寄存器** | **作用**                     | **AT&T语法示例** | **Intel语法示例** |
|------------|------------------------------|------------------|-------------------|
| `cs`       | 代码段基址（当前执行代码段） | `%cs`           | `cs`             |
| `ds`       | 数据段基址（默认数据访问段） | `%ds`           | `ds`             |
| `ss`       | 栈段基址                     | `%ss`           | `ss`             |
| `es`       | 附加数据段                   | `%es`           | `es`             |
| `fs`, `gs` | 额外附加段（用于特定系统用途）| `%fs`           | `fs`             |

#### **2. 反汇编工具默认语法**
- **objdump**：  
  ```bash
  objdump -d a.out          # 默认输出 AT&T 语法
  objdump -d -M intel a.out # 强制切换为 Intel 语法
  ```
- **GDB**：  
  ```bash
  (gdb) set disassembly-flavor intel  # 切换为 Intel 语法
  (gdb) disassemble main
  ```

#### **3. AT&T 语法示例解析**

```c
int add(int a, int b) {
    return a + b;
}
```

**GCC 生成的 AT&T 汇编（`gcc -S`）**

```asm
add:
    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax   # 从栈中加载第一个参数 a (ebp+8)
    addl    12(%ebp), %eax  # 加上第二个参数 b (ebp+12)
    popl    %ebp
    ret
```
**等效的 Intel 语法**

```asm
add:
    push ebp
    mov ebp, esp
    mov eax, [ebp+8]    ; 加载 a
    add eax, [ebp+12]   ; 加上 b
    pop ebp
    ret
```

## 3.2 C程序执行的两个视角

- 静态：C 代码的连续一段总能对应到一段连续的机器指令
- 动态：C 代码执行的状态总能对应到机器的状态
  - 源代码视角
    - 函数、变量、指针……
  - 机器指令视角
    - 寄存器、内存、地址……

- 两个视角的共同之处：内存
  - 代码、变量(源代码视角) = 地址+ 长度(机器指令视角)
  - (不太严谨地) 内存= 代码+ 数据+ 堆栈

因此理解C 程序执行最重要的就是内存模型。

```
void printptr(void *p) {
 printf("p = %p; *p = %016lx\n", p, *(long *)p); 
} 
int x; 
int main(int argc, char *argv[]) { 
 printptr(main); // 代码
 printptr(&main); 
 printptr(&x); // 数据
 printptr(&argc); // 堆栈
 printptr(argv); 
 printptr(&argv); 
 printptr(argv[0]); 
}
```