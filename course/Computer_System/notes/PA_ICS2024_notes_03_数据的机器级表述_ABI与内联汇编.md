
## 5 - 数据的机器级表述

### 5.1 - 位运算与单指令多数据

[Hacker's Delight](https://www.hackersdelight.org/)

#### **1. |S|**

Bit Set: 求 |S| (S二进制表示有多少个1)。

```c
int bitset_size(uint32_t S) { 
    int n; 
    for (int i = 0; i < 32; i++) { 
        n += bitset_contains(S, i); 
    } 
    return n; 
}

int bitset_size1(uint32_t S) { // SIMD
    S = (S & 0x55555555) + ((S >> 1) & 0x55555555); 
    S = (S & 0x33333333) + ((S >> 2) & 0x33333333); 
    S = (S & 0x0F0F0F0F) + ((S >> 4) & 0x0F0F0F0F); 
    S = (S & 0x00FF00FF) + ((S >> 8) & 0x00FF00FF); 
    S = (S & 0x0000FFFF) + ((S >> 16) & 0x0000FFFF); 
    return S; 
}
```

#### **2. Lowbit**

Lowbit：找到最右边的1。

 x = 0b+++++100  
-x = 0b-----011+0b1 = 0b-----100  
x&-x：0b00000100 à lowbit

#### **3. $\lfloor \log_2(x) \rfloor$**

等同于31−clz(x)。
```
int clz(uint32_t x) { 
    int n = 0; 
    if (x <= 0x0000ffff) n += 16, x <<= 16; 
    if (x <= 0x00ffffff) n += 8, x <<= 8; 
    if (x <= 0x0fffffff) n += 4, x <<= 4; 
    if (x <= 0x3fffffff) n += 2, x <<= 2; 
    if (x <= 0x7fffffff) n ++; 
    return n; 
}

#define LOG2(x) ("-01J2GK-3@HNL;-=47A-IFO?M:<6-E>95D8CB"[(x) % 37] - '0')
```

- 要求输入 x 必须为2的幂次（如 x=1, 2, 4, 8, ...）。
- 取模运算：(x) % 37，将 x 映射到 0-36 的索引。
- 字符查找：通过索引在字符串中获取对应字符。
- 数值转换：字符减去 '0' 的 ASCII 值（48），得到整数结果。

### 5.2 - 整数溢出与Undefined Behavior

常见的 UB：非法内存访问 (空指针解引用、数组越界、写只读内存等)、被零除、有符号整数溢出、函数没有返回值……

可通过fsanitize检查未定义行为。
```
gcc–fsanitize=undefined a.c && ./a.out
```

### 5.3 - 浮点数：IEEE 754

IEEE 754单精度浮点数（32位）的表示方法遵循国际标准，将数值分为三个部分：**符号位（Sign）**、**指数部分（Exponent）**和**尾数部分（Mantissa）**。

#### **1. 存储结构**

单精度浮点数占32位，按以下方式划分：
- **符号位（1位）**：`0` 表示正数，`1` 表示负数。
- **指数部分（8位）**：采用**偏移码（Bias）**表示，偏移量为 `127`。
- **尾数部分（23位）**：存储二进制小数部分，隐含最高位的 `1`（特殊情况除外）。

![IEEE 754单精度浮点数结构](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/1280px-Float_example.svg.png)

- 越大的数字，距离下一个实数的距离就越大
    - 可能会带来相当的绝对误差
    - 因此很多数学库都会频繁做归一化


#### **2. 计算规则**

浮点数的实际值由以下公式计算：
$$
\text{Value} = (-1)^{\text{Sign}} \times (1 + \text{Mantissa}) \times 2^{(\text{Exponent} - 127)}
$$
1. **符号位**：决定数值的正负。
2. **指数部分**：存储的指数值需减去偏移量 `127`，得到实际指数。
3. **尾数部分**：隐含最高位的 `1`（即 `1.尾数`），除非是次正规数。


#### **3. 特殊值的表示**
| **类型**       | **符号位** | **指数部分** | **尾数部分**        | **说明**                          |
|----------------|------------|--------------|---------------------|-----------------------------------|
| **正零**       | `0`        | 全 `0`       | 全 `0`              | 表示 `+0.0`                       |
| **负零**       | `1`        | 全 `0`       | 全 `0`              | 表示 `-0.0`                       |
| **次正规数**   | `0/1`      | 全 `0`       | 非全 `0`            | 极小值，隐含最高位为 `0`          |
| **正规数**     | `0/1`      | 非全 `0/1`   | 任意                | 标准浮点数                        |
| **正无穷大**   | `0`        | 全 `1`       | 全 `0`              | `+∞`（如 `1.0/0.0`）             |
| **负无穷大**   | `1`        | 全 `1`       | 全 `0`              | `-∞`（如 `-1.0/0.0`）            |
| **NaN**        | `0/1`      | 全 `1`       | 非全 `0`            | 非数值（如 `0.0/0.0` 或 `√-1`）  |


#### **4. 示例解析**

以数值 **-5.75** 转换为单精度浮点数为例：

**步骤 1：转换为二进制**
- **整数部分**：5 = \(101_2\)
- **小数部分**：0.75 = \(0.11_2\)（因 \(0.5 + 0.25 = 0.75\)）
- **合并结果**：\(-5.75 = -101.11_2\)

**步骤 2：规范化科学记数法**
$$
-101.11_2 = -1.0111_2 \times 2^2
$$
- **符号位**：`1`（负数）
- **实际指数**：`2`
- **尾数**：`0111`（去除隐含的 `1.` 后的小数部分）

**步骤 3：编码各部分**
- **指数部分**：\(2 + 127 = 129\) → 二进制 `10000001`
- **尾数部分**：`0111` 后补零至23位 → `01110000000000000000000`

**最终二进制表示**：
$$
\underbrace{1}_{\text{符号位}} \quad \underbrace{10000001}_{\text{指数部分}} \quad \underbrace{01110000000000000000000}_{\text{尾数部分}}
$$
对应十六进制：`0xC0B80000`

#### **5. 特殊值示例**
1. **零**：
   - 正零：`0 00000000 00000000000000000000000`
   - 负零：`1 00000000 00000000000000000000000`

2. **次正规数**（最小非零值）：
   - 指数全 `0`，尾数最低位为 `1`：
     $$
     0 00000000 00000000000000000000001 \approx \pm 2^{-126} \times 2^{-23} = 2^{-149} \approx 1.4 \times 10^{-45}
     $$

3. **无穷大**：
   - 正无穷：`0 11111111 00000000000000000000000`
   - 负无穷：`1 11111111 00000000000000000000000`


## 6 - ABI与内联汇编

### 6.1 Application Binary Interface (ABI) 

**Application Binary Interface (ABI) 详解**

**ABI（应用二进制接口）** 是二进制程序与操作系统、硬件或其他二进制程序（如库）交互时遵循的底层规范。它定义了编译后的代码如何在二进制级别交互，确保不同模块（如可执行文件、动态库、操作系统内核）能够无缝协作。

#### **1. ABI 的核心组成**

ABI 涵盖多个维度的约定，主要包括：
1. **调用约定（Calling Convention）**  
   - 函数参数的传递顺序（如从左到右或从右到左）。  
   - 参数存储位置（寄存器 vs 栈）。  
   - 栈的清理责任（调用者清理或被调用者清理）。  
   - 返回值存储方式（如 `EAX` 寄存器或内存地址）。  
   *示例*：`cdecl`（C 默认）、`stdcall`（Windows API）、`System V AMD64`（Linux/macOS）。

2. **数据类型与内存布局**  
   - 基本类型的大小（如 `int` 是 4 字节）。  
   - 结构体/联合体的对齐方式（如 4 字节对齐）。  
   - 字节序（大端序 vs 小端序）。

3. **名称修饰（Name Mangling）**  
   - 编译器将函数名、参数类型编码为唯一符号（如 C++ 的 `_Z3addii` 表示 `int add(int, int)`）。  
   *问题*：不同编译器的修饰规则不同，导致二进制不兼容。

4. **异常处理与运行时支持**  
   - 异常传播机制（如 DWARF 或 SEH）。  
   - 动态类型信息（RTTI）的存储方式。

5. **系统调用与中断处理**  
   - 程序如何通过特定指令（如 `syscall`）请求操作系统服务。  
   - 中断处理例程的上下文保存规则。

6. **二进制文件格式**  
   - 可执行文件结构（如 ELF、PE、Mach-O）。  
   - 符号表、重定位表的组织方式。

#### **2. C 函数调用过程中参数传递、栈帧管理及返回值返回的详细步骤**

**1. 不同调用约定的差异**
| **调用约定** | **参数传递**      | **栈清理责任** | **返回值存储**       |
|-------------|------------------|---------------|---------------------|
| **cdecl**   | 栈（从右向左）     | 调用者         | EAX                 |
| **stdcall** | 栈（从右向左）     | 被调用者       | EAX                 |
| **fastcall**| 寄存器和栈混合     | 被调用者       | EAX/EDX             |
| **System V**| 寄存器优先（x64） | 被调用者       | RAX/RDX/XMM0-XMM1   |

**2. 函数调用栈帧示意图**
```
高地址
+------------------+
| 调用者栈帧        |
| ...              |
| 参数3            | ← EBP + 16
| 参数2            | ← EBP + 12
| 参数1            | ← EBP + 8
| 返回地址          | ← EBP + 4
| 旧EBP            | ← EBP
| 局部变量1         | ← EBP - 4
| 局部变量2         | ← EBP - 8
| ...              | ← ESP
低地址
```

**3. 总结**
- **参数传递**：通过栈或寄存器，顺序由调用约定决定。
- **栈帧管理**：通过 `EBP` 定位参数和局部变量。
- **返回值**：小数据通过寄存器返回，大数据通过内存返回。
- **栈平衡**：调用者或被调用者负责清理参数栈，取决于调用约定。

**3. 寄存器与函数调用**

准备参数：在调用函数之前，调用者需要准备好要传递给函数的参数。  
将参数放入寄存器：根据 ABI 的规定，将参数放入指定的寄存器中。对于整数和指针类型的参数，**前六个参数分别放入 RDI, RSI, RDX, RCX, R8, 和 R9 寄存器**。如果函数需要的参数少于六个，则只使用必要的寄存器。  
调用函数：使用 CALL 指令调用函数。此时，CPU 会将当前的指令地址（即 CALL 指令后将要执行的指令地址）压入堆栈，并跳转到被调用函数的地址开始执行。  
函数执行：被调用的函数开始执行，它可以从上述寄存器中读取传递给它的参数。 
函数返回：函数执行完毕后，结果通常**通过 RAX 寄存器返回给调用者**（对于整数和指针类型的结果）。然后，函数使用 RET 指令返回到调用者，此时 CPU 会从堆栈中弹出之前保存的返回地址，并跳转到这个地址继续执行程序。  
处理返回值：调用者可以从 RAX 寄存器中读取函数的返回值（如果函数有返回值的话）。  

```
int add(int a, int b) {
    return a + b;
}
 
// x86-64 汇编层面
asm
MOV RDI, 3    ; 将第一个参数 3 放入 RDI 寄存器
MOV RSI, 4    ; 将第二个参数 4 放入 RSI 寄存器
CALL add      ; 调用 add 函数
MOV result, RAX ; 将返回值存储到变量 result 中
```

### 6.2 Inline Assembly

在 C 语言中，**内联汇编（Inline Assembly）** 允许直接在代码中嵌入汇编指令，用于性能优化、访问硬件特性或执行特定操作。以下是基本用法指南（以 **GCC** 和 **x86/x86-64** 架构为例）：

#### **1. 基础语法**
GCC 使用 `asm` 关键字（或 `__asm__`）嵌入汇编代码，支持两种语法格式：**AT&T**（默认）和 **Intel**（需指定选项）。

```c
asm [volatile] (
    "汇编指令" 
    : 输出操作数列表     // 可选
    : 输入操作数列表     // 可选
    : clobber列表        // 可选（被破坏的寄存器或内存）
);
```
- **`volatile`**：禁止编译器优化这段汇编代码（类似 `volatile` 变量）。
- **操作数列表**：指定 C 变量与寄存器的映射关系。
- **clobber列表**：声明汇编代码会修改的寄存器或内存。


#### **2. 操作数约束（Constraints）**
操作数通过约束符指定寄存器或内存位置，常用约束符如下：

| **约束符** | **含义**                            |
|------------|-------------------------------------|
| `r`        | 任意通用寄存器                      |
| `a`        | `eax`/`rax`                         |
| `b`        | `ebx`/`rbx`                         |
| `c`        | `ecx`/`rcx`                         |
| `d`        | `edx`/`rdx`                         |
| `S`        | `esi`/`rsi`                         |
| `D`        | `edi`/`rdi`                         |
| `m`        | 内存地址                            |
| `i`        | 立即数（整数）                      |
| `g`        | 寄存器、内存或立即数                |
 
**操作数格式**
```c
[操作数名字] "约束符" (C变量)
```
- **输入操作数**：`"约束符" (变量)`
- **输出操作数**：`"=约束符" (变量)`（注意 `=` 表示写入）


#### **3. 示例代码**

```c
int a = 5, b = 3, result;
asm volatile (
    "add %1, %0"        // %0 是 result，%1 是 a
    : "=r"(result)       // 输出：result 存入寄存器
    : "r"(a), "0"(b)     // 输入：a 存入寄存器，"0" 表示与第0个操作数共用寄存器（即 b 与 result 同寄存器）
);

// 结果：result = a + b = 8

int foo(int x, int y) { 
int z; 
x++; y++; 
asm ( 
"addl %1, %2; "
 "movl %2, %0; "
 : "=r"(z) // output
 : "r"(x), "r"(y) // input
 ); 
return z; 
}

int foo(int x, int y) { 
int z; 
x++; y++; 
asm ( 
"addl %1, %2; "
 "movl %2, %0; "
 : "=&r"(z) // output
 : "r"(x), "r"(y) // input
 ); 
return z; 
}
```

#### **4. Clobber 列表**
声明汇编代码中**隐式修改的寄存器或内存**，防止编译器错误优化：
```c
asm volatile (
    "movl $5, %%eax;"
    "movl %%eax, %0;"
    : "=m"(output)      // 输出到内存
    :                    // 无输入
    : "eax"             // 声明 eax 被修改
);
```
- **常用标记**：
  - **寄存器**：`"eax"`, `"rsi"` 等。
  - **内存**：`"memory"`（表示汇编代码可能修改任意内存）。
  - **条件码**：`"cc"`（表示修改了标志寄存器）。

### **5. 编译器差异（GCC vs MSVC）**
| **功能**         | **GCC**                       | **MSVC**                     |
|------------------|-------------------------------|-------------------------------|
| **关键字**       | `asm` 或 `__asm__`            | `__asm`                       |
| **语法风格**     | AT&T（默认）                  | Intel                         |
| **多行汇编**     | 用 `\n\t` 分隔                | 直接换行                      |
| **访问变量**     | 通过操作数约束                | 直接使用 C 变量名（自动替换） |

**MSVC 示例**：
```c
__asm {
    mov eax, 5
    add eax, ecx
    mov result, eax
}
```