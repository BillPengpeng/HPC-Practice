
## 8 - I/O设备选讲

### 8.1 设备-处理器接口（cont’d）

CPU可以直接通过指令读写这些寄存器
- Port-mapped I/O (**PMIO**)
    - I/O地址空间（port）
    - CPU直连I/O总线
- Memory-mapped I/O (**MMIO**)
    - 直观：使用普通内存读写指令就能访问
    - 带来了一些设计和实现的麻烦：编译器优化、缓存、乱序执行

### 8.2 两个特殊的I/O设备

#### 总线

- 系统里可能有很多 (甚至是可变的) I/O 设备，总线实现了设备的查找、映射、和命令/数据的转发
- CPU 可以只直接连接到总线，总线可以连接其他总线，例子：查看连接外设lspci-t, lsusb-t

#### 中断控制器

管理多个产生中断的设备
- 汇总成一个中断信号给CPU
- 支持中断的屏蔽、优先级管理等
- 中断 = 硬件驱动的函数调用
- 中断 + 更大的内存 = 分时多线程
- 分时多线程+ 虚拟存储 = 进程

```
// 相当于在每条语句后都插入
if (pending_io && int_enabled) { 
interrupt_handler(); 
pending_io = 0; 
}
```

### 8.3 Hello world！

[Hello的调用Markmap](https://ysyx.oscc.cc/slides/hello-x86.html)
 
#### **Hello world！系统调用**

在C语言中执行“Hello World”程序，从启动到屏幕显示“Hello World”的整个过程中，涉及的主要系统调用如下：

**1. 程序加载与启动**
- **系统调用：`execve`**
  - **作用**：加载可执行文件到内存并启动进程。
  - **流程**：
    1. Shell调用`fork()`创建子进程。
    2. 子进程调用`execve("./hello", argv, envp)`加载并执行程序。
    3. 内核验证可执行文件格式（如ELF），分配内存，初始化代码段和数据段。

**2. 动态链接与库加载**
- **系统调用：`openat`、`mmap`、`mprotect`**
  - **作用**：加载动态链接库（如`libc.so`）。
  - **流程**：
    1. 通过`openat`打开动态库文件。
    2. 使用`mmap`将库文件映射到内存。
    3. 通过`mprotect`设置内存权限（如代码段只读）。
  - **示例**：
    ```bash
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f...
    ```

**3. 标准输出初始化**
- **系统调用：`ioctl`**
  - **作用**：获取终端信息（如窗口大小、缓冲模式）。
  - **示例**：
    ```bash
    ioctl(1, TCGETS, {B38400 opost isig icanon echo ...}) = 0
    ```

**4. 输出字符串到屏幕**
- **系统调用：`write`**
  - **作用**：将数据写入文件描述符（`stdout` 对应描述符1）。
  - **流程**：
    1. `printf("Hello World\n")`触发标准库将字符串存入缓冲区。
    2. 遇到换行符`\n`时，行缓冲模式强制刷新缓冲区。
    3. 标准库调用`write(1, "Hello World\n", 12)`。
  - **示例**：
    ```bash
    write(1, "Hello World\n", 12) = 12
    ```

**5. 程序退出**
- **系统调用：`exit_group`**
  - **作用**：终止进程及其所有线程。
  - **流程**：
    1. `main`函数返回后，C运行时调用`exit(0)`。
    2. 最终触发`exit_group(0)`系统调用。
  - **示例**：
    ```bash
    exit_group(0) = ?
    ```

**6. 完整系统调用跟踪示例（`strace`输出）**
```bash
execve("./hello", ["./hello"], 0x7ffd... ) = 0
brk(NULL)                               = 0x55...
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF...", 832)              = 832
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f...
mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f...
mprotect(0x7f..., 1847296, PROT_NONE)   = 0
mmap(0x7f..., 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0) = 0x7f...
mmap(0x7f..., 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18e000) = 0x7f...
mmap(0x7f..., 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1d6000) = 0x7f...
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f...)        = 0
mprotect(0x7f..., 12288, PROT_READ)     = 0
write(1, "Hello World\n", 12)           = 12
exit_group(0)                           = ?
```

**7. 总结**
| **阶段**         | **关键系统调用** | **作用**                          |
|------------------|------------------|-----------------------------------|
| 程序加载         | `execve`         | 加载可执行文件并启动进程           |
| 动态链接         | `openat`、`mmap` | 加载共享库到内存                   |
| 标准输出初始化   | `ioctl`          | 配置终端属性                      |
| 输出字符串       | `write`          | 将数据写入标准输出                 |
| 程序终止         | `exit_group`     | 结束进程                          |

通过以上系统调用，操作系统完成了从程序加载到屏幕输出的完整流程。


#### **Hello world！整体流程**

以下是 **`printf("Hello World\n")` 从用户层调用到屏幕显示的全过程**，涵盖 **应用层、标准库层、内核层、设备驱动层和硬件层** 的详细交互流程：

**1. 用户层：格式化字符串处理**
- **代码调用**：
  ```c
  printf("Hello World\n");
  ```
- **作用**：标准库函数 `printf` 将格式化字符串存入**用户空间缓冲区**。
- **关键机制**：
  - **缓冲策略**：
    - **行缓冲（Line Buffering）**：遇到 `\n` 时自动刷新缓冲区。
    - **全缓冲（Full Buffering）**：缓冲区满时刷新（如文件写入）。
    - **无缓冲（Unbuffered）**：立即输出（如 `stderr`）。
  - **减少系统调用**：通过缓冲区合并多次写入，减少上下文切换开销。

**2. 标准库层：触发系统调用**
- **函数调用链**：
  ```c
  printf → vfprintf → write
  ```
- **系统调用入口**：
  - **`write(int fd, const void *buf, size_t count)`**：将数据写入文件描述符 `fd`（`stdout` 对应 `fd=1`）。
- **参数传递**：
  - `fd=1`：标准输出文件描述符。
  - `buf="Hello World\n"`：待写入数据。
  - `count=12`：数据长度（含换行符）。


**3. 内核层：处理系统调用**  
**(1) 系统调用入口** 
- **触发方式**：
  - **x86-64**：`syscall` 指令（陷入内核态）。
  - **参数传递**：通过寄存器（`rax=1` 表示 `sys_write`）。
- **内核函数**：`sys_write()` 处理写操作。

**(2) 虚拟文件系统（VFS）**
- **文件描述符解析**：
  - 根据 `fd=1` 查找进程的**文件描述符表**，找到对应的 `struct file`。
  - `stdout` 通常指向 **终端设备**（如 `/dev/tty1`）或 **伪终端**（如 SSH 会话的 `pts`）。
- **操作路由**：
  - 调用 `file->f_op->write()`，路由到具体设备的写方法。

**(3) 终端设备驱动**
- **字符设备驱动**：
  - 终端驱动（如 `tty driver`）处理数据写入。
  - **转换处理**：将 `\n` 转换为 `\r\n`（依赖终端配置）。
  - **行规则（Line Discipline）**：处理特殊字符（如 Ctrl+C 中断信号）。

**4. 设备驱动层：硬件交互**   
**(1) 控制台输出（Console）**
- **帧缓冲（Framebuffer）**：
  - **文本模式**：直接写入显存的**字符缓冲区**（如 80x25 文本模式，每个字符占2字节：ASCII + 属性）。
  - **图形模式**：通过位图字体渲染，将字符转换为像素写入显存。
- **操作流程**：
  1. 计算字符在显存中的位置（行、列）。
  2. 将字符的 ASCII 码和颜色属性写入显存对应地址。
  3. 显卡控制器定期读取显存，刷新到屏幕。

**(2) 串口/UART输出**
- **物理传输**：
  - 数据通过 **UART 控制器** 转换为串行信号。
  - 按波特率（如 115200 bps）逐位发送。
- **中断机制**：
  - 每发送完一个字节，触发中断通知 CPU。

**(3) 现代图形子系统（如DRM/KMS）**
- **显示渲染管理器（DRM/KMS）**：
  - 合成多个图形层（Layers），处理分辨率、刷新率。
  - 通过 PCIe/AGP 总线将渲染结果传输到显卡显存。


**5. 硬件层：数据显示**
**(1) 显存与显卡**
- **显存（VRAM）**：
  - 存储当前帧的像素数据。
  - 显卡的 **显示控制器** 定期（如 60Hz）读取显存，生成视频信号。
- **视频信号输出**：
  - **HDMI/DP**：数字信号传输像素数据。
  - **VGA**：模拟信号传输 RGB 分量。

**(2) 屏幕物理显示**
- **像素点亮**：
  - LCD 屏幕通过背光和液晶单元调节每个像素的亮度和颜色。
  - OLED 屏幕直接由有机发光二极管发光。
- **刷新过程**：
  - 逐行扫描（从左上到右下），每帧刷新时间为 `1/刷新率`（如 16.67ms @60Hz）。


**6. 全流程总结**
```
用户程序 → printf → 用户缓冲区 → write系统调用 → 内核VFS → 终端驱动 → 显存/串口 → 显卡控制器 → 屏幕显示
```
**关键数据流**
1. **用户空间**：格式化字符串存入缓冲区。
2. **系统调用**：`write` 陷入内核，传递数据地址和长度。
3. **内核处理**：VFS 路由到终端设备驱动。
4. **设备驱动**：将字符写入显存或串口缓冲区。
5. **硬件传输**：显卡/控制器将数据转换为视频信号。
6. **物理显示**：屏幕按刷新率点亮像素。

## 9 - 链接与加载

[Binary utilities](https://www.gnu.org/software/binutils/) 分析二进制文件的工具。

### 9.1 静态链接与加载

#### -fno-pic编译；-static链接  
以下是如何在 GCC 中使用 `-fno-pic` 编译选项和 `-static` 链接选项的详细说明，包括它们的用途、使用方法和注意事项。


**1. 选项说明**  
**(1) `-fno-pic`**   
- **作用**：禁用位置无关代码（Position-Independent Code, PIC）。
  - **PIC**：生成的代码可以在内存任意位置加载执行（用于共享库 `.so`）。
  - **`-fno-pic`**：生成非位置无关代码（使用绝对地址），通常用于静态可执行文件。
- **适用场景**：
  - 编译不需要动态链接的可执行文件。
  - 提升性能（减少一次间接寻址开销）。

**(2) `-static`**   
- **作用**：静态链接所有库，将依赖的库代码直接嵌入可执行文件。
  - **动态链接（默认）**：运行时依赖系统中的 `.so` 文件。
  - **静态链接**：无需外部库，但文件体积更大。
- **适用场景**：
  - 部署到无动态库的环境（如嵌入式系统）。
  - 避免依赖冲突（如特定库版本问题）。

**2. 使用方法**   
**(1) 编译单个文件**
```bash
gcc -fno-pic -c main.c -o main.o
```
- **`-c`**：仅编译不链接。
- **`-fno-pic`**：编译目标文件时不生成位置无关代码。

**(2) 静态链接生成可执行文件**   
```bash
gcc -static main.o -o main
```
- **`-static`**：强制链接静态库（如 `libc.a` 而非 `libc.so`）。

**(3) 一步编译并静态链接**   
```bash
gcc -fno-pic -static main.c -o main
```

**3. 验证静态链接**   
**(1) 检查文件类型**   
```bash
file main
```
- **输出示例**：
  ```bash
  main: ELF 64-bit LSB executable, x86-64, statically linked, BuildID[sha1]=..., for GNU/Linux 3.2.0, not stripped
  ```
  - `statically linked` 表示静态链接。

**(2) 查看动态依赖**    
```bash
ldd main
```
- **静态链接的输出**：
  ```bash
  not a dynamic executable
  ```

### 9.2 ELF文件类型


ELF（Executable and Linkable Format）文件是类Unix系统（如Linux、BSD）中用于可执行文件、共享库、目标文件和核心转储的标准格式。ELF文件的类型由其文件头中的`e_type`字段定义，主要分为以下几类：


**1. 核心类型**  
**(1) `ET_NONE`（0x00）**  
- **描述**：未知或未指定类型。
- **用途**：通常表示无效或未初始化的ELF文件。

**(2) `ET_REL`（0x01）**  
- **描述**：**可重定位文件**（Relocatable File）。
- **文件扩展名**：`.o`（目标文件）。
- **特点**：
  - 包含代码、数据、符号表和重定位信息。
  - 尚未链接，需通过链接器（如`ld`）与其他目标文件或库合并生成可执行文件或共享库。
- **示例**：编译后的`.o`文件（`gcc -c main.c`生成`main.o`）。

**(3) `ET_EXEC`（0x02）**  
- **描述**：**可执行文件**（Executable File）。
- **文件扩展名**：无扩展名（如`/bin/ls`）。
- **特点**：
  - 可直接由操作系统加载执行。
  - 包含固定的加载地址（静态链接）。
- **示例**：编译后的可执行程序（`gcc main.c -o main`）。

**(4) `ET_DYN`（0x03）**  
- **描述**：**共享目标文件**（Shared Object File）。
- **文件扩展名**：`.so`（动态库）或位置无关可执行文件（PIE）。
- **特点**：
  - 动态库（`.so`）在运行时由动态链接器（如`ld-linux.so`）加载。
  - 位置无关代码（PIC），可在任意内存地址加载。
- **示例**：`libc.so`、PIE可执行文件（`gcc -pie main.c -o main`）。

**(5) `ET_CORE`（0x04）**  
- **描述**：**核心转储文件**（Core Dump File）。
- **文件扩展名**：通常为`core`或`core.<pid>`。
- **特点**：
  - 记录程序崩溃时的内存、寄存器状态。
  - 用于调试（如`gdb`分析崩溃原因）。
- **生成方式**：通过`ulimit -c unlimited`启用，程序崩溃时自动生成。

**2. 类型对比**  
| **类型**      | **标识值** | **典型文件**    | **是否可执行** | **是否需链接** |
|---------------|------------|-----------------|----------------|----------------|
| `ET_NONE`     | 0x00       | 无效文件        | ❌              | ❌              |
| `ET_REL`      | 0x01       | `.o`目标文件    | ❌              | ✔️（需链接）    |
| `ET_EXEC`     | 0x02       | 静态可执行文件  | ✔️              | ❌              |
| `ET_DYN`      | 0x03       | `.so`动态库/PIE | ✔️（PIE时）     | ❌              |
| `ET_CORE`     | 0x04       | `core`转储文件  | ❌              | ❌              |


### 9.3 可重定位目标文件

可重定位目标文件（Relocatable Object File，即 `.o` 文件）是编译后但尚未链接的中间文件，其ELF结构为后续链接过程提供必要信息。以下是其核心组成部分及作用：


**1. ELF可重定位文件基本结构**

```
+-----------------------+
|      ELF Header       |  ▶ 文件头，描述整体结构
+-----------------------+
|    Section Headers    |  ▶ 节头表，描述各节的元数据
+-----------------------+
|          .text        |  ▶ 代码段（机器指令）
+-----------------------+
|          .data        |  ▶ 已初始化的全局/静态变量
+-----------------------+
|          .bss         |  ▶ 未初始化的全局/静态变量（仅占位，无实际数据）
+-----------------------+
|        .rodata        |  ▶ 只读数据（如字符串常量）
+-----------------------+
|       .symtab         |  ▶ 符号表（函数、变量名及其属性）
+-----------------------+
|       .strtab         |  ▶ 字符串表（符号名称等字符串）
+-----------------------+
| .rel.text / .rel.data |  ▶ 重定位表（代码/数据段的地址修正信息）
+-----------------------+
|     其他可选节        |  ▶ 如.debug（调试信息）、.comment（注释）
+-----------------------+
```

**2. ELF Header（ELF文件头）**
- **位置**：文件起始位置。
- **作用**：描述文件类型、目标架构、节头表位置等全局信息。
- **关键字段**：
  ```c
  typedef struct {
    unsigned char e_ident[16];  // Magic数（7F 45 4C 46）
    Elf64_Half    e_type;       // 文件类型（ET_REL=0x01）
    Elf64_Half    e_machine;    // 目标架构（如x86-64=0x3E）
    Elf64_Off     e_shoff;      // 节头表（Section Headers）的文件偏移
    Elf64_Half    e_shentsize;  // 单个节头表项的大小
    Elf64_Half    e_shnum;      // 节头表项的数量
    Elf64_Half    e_shstrndx;   // 节名称字符串表在节头表中的索引
  } Elf64_Ehdr;
  ```

**3. Section Headers（节头表）**
- **位置**：由ELF Header中的`e_shoff`字段指定。
- **作用**：描述每个节（Section）的名称、类型、地址、大小等属性。
- **关键字段**：
  ```c
  typedef struct {
    Elf64_Word  sh_name;    // 节名称在.strtab中的偏移
    Elf64_Word  sh_type;    // 节类型（如SHT_PROGBITS=代码/数据）
    Elf64_Xword sh_flags;   // 节属性（如可读、可写、可执行）
    Elf64_Addr  sh_addr;    // 内存地址（链接前为0）
    Elf64_Off   sh_offset;  // 节在文件中的偏移
    Elf64_Xword sh_size;    // 节的大小
    Elf64_Word  sh_link;    // 相关节的索引（如符号表关联的字符串表）
    Elf64_Word  sh_info;    // 附加信息（如重定位节的符号表索引）
  } Elf64_Shdr;
  ```

**4. 关键节（Sections）详解**   
**(1) `.text`**
- **类型**：`SHT_PROGBITS`
- **属性**：`SHF_ALLOC | SHF_EXECINSTR`
- **内容**：编译后的机器指令（函数代码）。

**(2) `.data`**
- **类型**：`SHT_PROGBITS`
- **属性**：`SHF_ALLOC | SHF_WRITE`
- **内容**：已初始化的全局变量和静态变量。

**(3) `.bss`**
- **类型**：`SHT_NOBITS`
- **属性**：`SHF_ALLOC | SHF_WRITE`
- **内容**：未初始化的全局/静态变量，文件中不占空间，仅记录大小。

**(4) `.rodata`**
- **类型**：`SHT_PROGBITS`
- **属性**：`SHF_ALLOC`
- **内容**：只读数据（如字符串常量、常量数组）。

**(5) `.symtab`（符号表）**
- **类型**：`SHT_SYMTAB`
- **内容**：所有符号（函数、变量）的信息。
  ```c
  typedef struct {
    Elf64_Word  st_name;   // 符号名在.strtab中的偏移
    unsigned char st_info; // 符号类型（函数/变量）和绑定属性（全局/局部）
    unsigned char st_other;
    Elf64_Half  st_shndx;  // 符号所属节的索引（如.text=1）
    Elf64_Addr  st_value;  // 符号的偏移量（在节内）
    Elf64_Xword st_size;   // 符号大小（如函数代码长度）
  } Elf64_Sym;
  ```

**(6) `.rel.text` 和 `.rel.data`（重定位表）**
- **类型**：`SHT_REL` 或 `SHT_RELA`
- **内容**：记录代码段和数据段中需要重定位的位置。
  ```c
  typedef struct {
    Elf64_Addr  r_offset;  // 需要重定位的位置在节内的偏移
    Elf64_Xword r_info;    // 低32位：符号表索引；高32位：重定位类型
    Elf64_Sxword r_addend; // 附加常数（仅SHT_RELA）
  } Elf64_Rela;
  ```

**(7) `.strtab` 和 `.shstrtab`**
- **`.strtab`**：普通字符串表，存储符号名称（如函数名`main`）。
- **`.shstrtab`**：节名称字符串表，存储节名称（如`.text`、`.data`）。


**5. 示例：使用工具查看结构**
**(1) 查看ELF头**
```bash
readelf -h main.o
```
输出示例：
```
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          792 (bytes into file)
  ...
```

**(2) 查看节头表**
```bash
readelf -S main.o
```
可重定位目标文件中，每个可装入节的起始地址总是0。
输出示例：
```
Section Headers:
  [Nr] Name   Type      Address          Off    Size   ES Flg Lk Inf Al
  [ 0]        NULL      0000000000000000 000000 000000 00      0   0  0
  [ 1] .text  PROGBITS  0000000000000000 000040 000015 00  AX  0   0  1
  [ 2] .data  PROGBITS  0000000000000000 000058 000008 00  WA  0   0  4
  [ 3] .bss   NOBITS    0000000000000000 000060 000004 00  WA  0   0  4
  [ 4] .symtab SYMTAB    0000000000000000 000060 0000a8 18      5   6  8
  [ 5] .strtab STRTAB    0000000000000000 000108 00001d 00      0   0  1
  [ 6] .shstrtab STRTAB    0000000000000000 000125 000028 00      0   0  1
```

**为什么要把程序指令和数据分开放？**：权限隔离、缓存命中、共享内存。  

**6. 重定位过程的关键角色**
- **符号表（.symtab）**：告知链接器哪些符号需要解析（如未定义的`printf`）。
- **重定位表（.rel.*）**：指示哪些指令/数据需要修正地址（如`call printf`的偏移量）。
- **节地址**：链接器将各目标文件的节合并后，重新计算符号的绝对地址。

**7. 总结**   
可重定位目标文件通过 **代码段、数据段、符号表和重定位表** 的协作，为链接器提供必要信息。链接器最终将多个`.o`文件的节合并，解析符号引用，修正地址，生成可执行文件（`ET_EXEC`）或共享库（`ET_DYN`）。

### 9.4 符号解析和重定位

将各目标文件的代码和数据段合并到进程虚拟地址空间，并修正符号引用。

1.**合并输入段**：
   - 将各目标文件的相同类型段（如 `.text`、`.data`）合并为输出段。
   - **示例**：`main.o` 的 `.text` 和 `func.o` 的 `.text` 合并为可执行文件的 `.text` 段。

2.**分配运行时地址**：
   - 链接器为每个输出段分配基地址（由链接脚本指定，默认从 `0x400000` 开始）。
   - **公式**：符号地址 = 段基址 + 符号在段内的偏移。
     - 如 `.text` 段基址为 `0x400000`，`func` 在段内偏移 `0x200`，则 `func` 地址为 `0x400200`。

3.**重定位条目处理**：
   - **重定位表（.rel.text / .rel.data）**：记录需要修正的位置及对应符号。
     - **条目结构**：
       ```c
       typedef struct {
         Elf64_Addr  r_offset;  // 需要修正的位置在段内的偏移
         Elf64_Xword r_info;    // 符号表索引（低32位）和重定位类型（高32位）
         Elf64_Sxword r_addend; // 附加常数（用于某些重定位类型）
       } Elf64_Rela;
       ```
   - **常见重定位类型**：
     - **R_X86_64_PC32**：相对地址引用（如 `call func`）。
     - **R_X86_64_32**：绝对地址引用（如全局变量地址）。

4. **计算新地址并修正**：
   - **相对地址修正**（如函数调用）：
     ```
     修正值 = 符号地址 - 修正位置地址 - 指令长度
     ```
   - **绝对地址修正**（如全局变量访问）：
     ```
     修正值 = 符号地址
     ```

**示例**：
- `main.o` 中 `call func` 的指令在偏移 `0x100` 处。
- `func` 的最终地址为 `0x400200`，`.text` 段基址为 `0x400000`。
- 计算相对偏移(**下一条指令**)：`0x400200 - (0x400000 + 0x100) - 4 = 0xFC`。
- 将 `call` 指令的操作数修正为 `0xFC`。

**gcc -Wl,--verbose**
使用 gcc -Wl,--verbose 命令可以查看链接器（ld）的详细操作过程，包括链接脚本、库搜索路径、符号解析和内存分配等关键信息。
 
### 9.2 动态链接

动态链接是一种在程序运行时而非编译时将所需库函数和资源加载到内存的机制。以下是对动态链接的详细解析：

**1. 动态链接的核心概念**  
- **延迟绑定**：程序启动时不加载所有依赖库，而是在首次调用函数时加载。
- **共享内存**：多个进程共享同一份库的代码段（只读），减少内存占用。
- **依赖管理**：通过动态链接器（如 `ld-linux.so`）解析运行时依赖。

**2. 动态链接 vs 静态链接**  
| **特性**       | **动态链接**                     | **静态链接**                     |
|----------------|----------------------------------|----------------------------------|
| **文件体积**   | 较小（仅记录依赖信息）           | 较大（包含所有依赖库代码）       |
| **内存占用**   | 共享库代码在内存中仅一份         | 每个进程独立加载库代码           |
| **更新维护**   | 替换库文件即可生效               | 需重新编译整个程序               |
| **启动速度**   | 略慢（需加载库）                 | 较快（无额外加载）               |
| **兼容性风险** | 需保证库版本兼容                 | 无外部依赖风险                   |

**3. 动态链接的工作流程**   
**(1) 编译阶段**   
- **生成位置无关代码（PIC）**：使用 `-fPIC` 编译库，确保代码可加载到任意地址。
- **记录依赖信息**：可执行文件中保存所需动态库的名称（如 `libc.so.6`）。

**(2) 程序启动**   
1. **加载动态链接器**：操作系统加载程序时，首先加载动态链接器（如 `/lib64/ld-linux-x86-64.so.2`）。
2. **加载依赖库**：动态链接器根据依赖列表（`DT_NEEDED`）递归加载所有库。
3. **符号解析**：解析函数和变量的地址，填充 **全局偏移表（GOT）** 和 **过程链接表（PLT）**。

**(3) 运行时调用**   
- **首次调用函数**：通过 PLT 跳转到动态链接器，查找函数地址并更新 GOT。
- **后续调用**：直接通过 GOT 中的地址跳转，无需重复解析。

**4. 动态链接的关键技术**   
**(1) 全局偏移表（GOT）**    
- **作用**：存储外部函数和变量的实际地址。
- **位置**：数据段（可写），每个进程独立。

**(2) 过程链接表（PLT）**   
- **作用**：延迟绑定的跳板代码，首次调用触发动态链接器解析地址。
- **流程**：
  1. `call func@PLT` → 跳转到 PLT 条目。
  2. PLT 首次调用通过 GOT 跳转到动态链接器。
  3. 动态链接器解析 `func` 地址并更新 GOT。
  4. 后续调用直接通过 GOT 跳转。

**(3) 动态链接器（Runtime Linker）**    
- **功能**：
  - 加载依赖库。
  - 处理符号重定位。
  - 管理版本兼容性（如符号版本控制）。

**5. 动态库的版本管理**   
**(1) 文件名约定**    
- **Linux**：`lib<name>.so.<major>.<minor>.<patch>`（如 `libc.so.6`）。
- **Windows**：`<name><version>.dll`（如 `vcruntime140.dll`）。
 
**(2) 符号版本控制**    
- **GNU扩展**：允许库中同一符号存在多个版本，确保兼容性。
- **示例**：
  ```c
  __asm__(".symver oldfunc, func@VERS_1");
  __asm__(".symver newfunc, func@@VERS_2");
  ```

**6. 动态链接的配置与管理**    
**(1) 库搜索路径**   
- **默认路径**：`/lib`, `/usr/lib`, `/usr/local/lib`。
- **自定义路径**：
  - 环境变量 `LD_LIBRARY_PATH`（临时）。
  - 配置文件 `/etc/ld.so.conf` 和 `ldconfig` 工具（永久）。

**(2) 调试工具**   
- **`ldd`**：查看程序的动态库依赖。
  ```bash
  ldd /bin/ls
  ```
- **`readelf -d`**：显示动态段信息（依赖库列表）。
  ```bash
  readelf -d myapp | grep NEEDED
  ```
- **`LD_DEBUG`**：启用动态链接调试信息。
  ```bash
  LD_DEBUG=libs ./myapp
  ```

**7. 动态链接的优缺点**     
**优点**   
- **节省资源**：多个进程共享同一份库代码。
- **灵活更新**：无需重新编译程序即可修复库漏洞。
- **模块化**：支持插件架构，运行时加载功能模块。

**缺点**    
- **依赖管理**：需确保目标环境安装了正确版本的库。
- **启动延迟**：首次加载库和解析符号增加启动时间。
- **安全风险**：恶意库注入（如 `LD_PRELOAD` 被滥用）。

**8. 示例：动态链接的实际应用**   
**(1) 编译动态库**  
```bash
# 编译为位置无关代码
gcc -fPIC -c mylib.c -o mylib.o
# 创建动态库
gcc -shared mylib.o -o libmylib.so
```

**(2) 链接动态库**   
```bash
gcc main.c -L. -lmylib -o myapp
```

**(3) 运行程序**  
```bash
# 临时添加库路径
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
./myapp
```

9.**总结**   
动态链接通过将库的加载推迟到运行时，实现了资源的高效利用和灵活的更新维护。其核心机制包括 **位置无关代码、GOT/PLT 表、动态链接器协作**，开发者需掌握依赖管理、符号解析和调试工具的使用，以应对兼容性和性能优化挑战。